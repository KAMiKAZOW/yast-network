/**
 * File:	include/network/modules.ycp
 * Package:	Network configuration
 * Summary:	Modules manipulation functions
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 *
 * All modules.conf settings are stored in a global variable Modules.
 * Deleted modules are in the global list DeletedModules.
 *
 * <pre>
 * map Modules = $[
 *     "alias" : $[
 *	   "eth0" : "ne",
 *	   "eth1" : "off",
 *         ...
 *     ],
 *     "options" : $[
 *	   "ne" : "io=0x220 irq=7" ],
 *         ...
 *     ]
 * ];
 *
 * list DeletedModules = [ "eth0" ];
 * </pre>
 */

{

textdomain "network";
import "Arch";
include "network/routines.ycp";

/**
 * Read Modules from files
 * @param devregex regular expression for the module type
 * @return true if sucess
 * @example ReadModules("eth|tr");
 */
global define boolean ReadModules(string devregex) ``{

    Modules = $[
	"alias" : $[],
	"options" : $[],
    ];

    string regex = "^(" + devregex + ")[0-9]*$";
    y2debug("regex=%1", regex);

    /* Read aliases */
    list aliases = SCR::Dir(.modules.alias);
    maplist(string al, aliases, ``{
	if(regexpmatch(al, regex)) {
	    string modul = SCR::Read(add(.modules.alias, al));
	    if(modul != nil)
		Modules["alias", al] = modul;
	}
    });

    /* Read options */
    list opts = SCR::Dir(.modules.options);
    maplist(string al, opts, ``{
	map optsmap = SCR::Read(add(.modules.options, al));
	if(optsmap != nil)
	    Modules["options", al] = map2string(optsmap);
    });

    y2debug("Modules=%1", Modules);
    return true;
}

/**
 * Write Modules to files
 * @return true if success
 */
global define boolean WriteModules() ``{

    boolean arcnet = false;
    y2debug("Modules=%1", Modules);

    /* Remove deleted modules */
    maplist(string d, DeletedModules, ``{
	y2debug("deleting: %1", d);
	SCR::Write(add(.modules.alias, d), nil);
	/* Keep options:
	 * SCR::Write(add(.modules.options, d), nil);
	 */
	SCR::Execute(.target.bash, sformat("/sbin/rmmod %1 2>&1", d));
    });
    DeletedModules = [];

    /* Write aliases */
    maplist(string m, string a, Modules["alias"]:$[], ``{
	if(a != nil && a != "") {
	    // y2milestone("%1 %2", add(.modules.alias, m), a);
	    SCR::Write(add(.modules.alias, m), a);
	    if(regexpmatch(a, "^arc")) arcnet = true;
	}
    });

    /* Write options */
    maplist(string m, string o, Modules["options"]:$[], ``{
	if(o != nil && o != "")
	    // y2milestone("%1 %2", add(.modules.options, m), string2map(o));
	    SCR::Write(add(.modules.options, m), string2map(o));
    });

    /* Preload ARCNet modules (#26858) */
    if(arcnet)
	SCR::Write(.modules.above.arcnet, "rfc1201 rfc1051 arc-rawmode");

    /* FIXME: s390 modules hack */
    if(false) {
	/* write module options */
	if(size(opts_map) > 0) {
	    /* write module options normally */
	    if(!Arch::s390)
		SCR::Write(.modules.options, opts_map, dev);
	    else {
		/* merge module options */
		if(typ == "iucv") {
		    map curopts = SCR::Read(.modules.options, "netiucv");
		    maplist(string k, string v, opts_map, ``{
			if(haskey(curopts, k))
			    change(curopts, k, curopts[k]:"" + ":" + v);
			else
			    change(curopts, k, v);
		    });
		    SCR::Write(.modules.options, curopts, "netiucv");
		}
		/* write options to chandev.conf */
		else {
		    path chandev = topath(".etc.chandev_conf."+mod+num);
		    if(typ == "escon") chandev = topath(".etc.chandev_conf.escon"+num);
		    y2milestone("Write(%1,%2)", chandev, opts);
		    SCR::Write(chandev, opts);
		}
	    }
	}
    }

    /* Finish him */
    SCR::Write(.modules, nil);

    return true;
}

/**
 * Update Modules map
 * @param name device name
 * @param check if check if module already exists
 * @return true if success
 */
global define boolean ChangeModule(string name, boolean check) ``{
    y2debug("Module=%1", Module);
    y2debug("Modules=%1", Modules);

    if(check && haskey(Modules["alias"]:$[], name)) {
	y2warning("Module already present: %1", name);
	/* Change it always and report only warning: return false; */
    }

    string m = Module["module"]:"";
    string o = Module["options"]:"";

    Modules["alias", name] = m;

    map m_orig = string2map(Modules["options", m]: "");
    map m_new = string2map(o);
    maplist(string mo, string op, m_new, ``{
	if(haskey(m_orig, mo)) m_orig[mo] = sformat("%1,%2", op, m_orig[mo]:"");
	else m_orig[m] = op;
    });

    Modules["options", m] = map2string(m_orig);

    y2debug("Modules=%1", Modules);
    return true;
}

/**
 * Delete a module from Modules map
 * @param name device name
 * @return true if success
 */
global define boolean DeleteModule(string name) ``{
    y2debug("Modules=%1", Modules);
    y2debug("DeletedModules=%1", DeletedModules);

    if(!haskey(Modules["alias"]:$[], name)) {
	y2error("Module not found: %1", name);
	return false;
    }

    Modules["alias"] = remove(Modules["alias"]:$[], name);
    change(DeletedModules, name);

    y2debug("Modules=%1", Modules);
    y2debug("DeletedModules=%1", DeletedModules);
    return true;
}

/**
 * Add a new kernel module
 * @param type added module type
 * @return true on success
 */
global define boolean AddModule(string type) ``{

    Module["module"] = "";
    Module["options"] = "";

    y2debug("Add(%1)", type);
    if(type == nil) {
	y2error("Invalid type: %1", type);
	return false;
    }

    /* FIXME: type dependent heuristics *//*
    Module["module"] = "";
    Module["options"] = ""; */

    return true;
}

/**
 * Select the given kernel module and fill internal variables
 * @param name module name
 * @return true on success
 */
global define boolean SelectModule(string name) ``{

    Module["module"] = "";
    Module["options"] = "";

    y2debug("Select(%1)", name);
    if(name != "" && !haskey(Modules["alias"]:$[], name)) {
	y2error("Invalid module: %1", name);
	return false;
    }

    string m = Modules["alias", name]:"";

    Module["module"] = m;
    Module["options"] = Modules["options", m]:"";

    y2debug("Select(module) = ", Module["module"]:"");
    y2debug("Select(options) = ", Module["options"]:"");

    return true;
}

/* EOF */
}
