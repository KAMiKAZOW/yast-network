/**
 * File:	include/network/modules.ycp
 * Package:	Network configuration
 * Summary:	Modules manipulation functions
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 *
 * All modules.conf settings are stored in a global variable Modules.
 * Deleted modules are in the global list DeletedModules.
 *
 * <pre>
 * map Modules = $[
 *     "eth0" : [ "module" : "tulip", "options" : "io=0x220 irq=7" ],
 *     "eth1" : [ "module" : "off" ],
 *     ...
 * ];
 *
 * list DeletedModules = [ "eth0" ];
 * </pre>
 */

{

textdomain "network";
import "Arch";
include "network/routines.ycp";

/**
 * Read Modules from files
 * @param devregex regular expression for the module type
 * @return true if sucess
 * @example ReadModules("eth|tr");
 */
global define boolean ReadModules(string devregex) ``{

    Modules = $[];
    string regex = "^(" + devregex + ")[0-9]*$";
    y2debug("regex=%1", regex);

    /* Read aliases */
    list aliases = SCR::Dir(.modules.alias);
    maplist(string al, aliases, ``{
	if(regexpmatch(al, regex)) {
	    string modul = SCR::Read(add(.modules.alias, al));
	    if(modul == nil) modul = "";
	    change(Modules, al, $["module" : modul]);
	}
    });

    /* Read options */
    list opts = SCR::Dir(.modules.options);
    maplist(string al, opts, ``{
	if(regexpmatch(al, regex)) {
	    map optsmap = SCR::Read(add(.modules.options, al));
	    if(optsmap != nil) {
		map oldopts = Modules[al]:$[];
		change(oldopts, "options", map2string(optsmap));
		change(Modules, al, oldopts);
	    }
	}
    });

    y2debug("Modules=%1", Modules);
    return true;
}

/**
 * Write Modules to files
 * @return true if success
 */
global define boolean WriteModules() ``{

    y2debug("Modules=%1", Modules);

    /* Remove deleted modules */
    maplist(string d, DeletedModules, ``{
	y2debug("deleting: %1", p);
	/* Delete only alias, keep options */
	SCR::Write(add(.modules.alias, d), nil);
	// SCR::Write(add(.modules.options, d), nil);
    });
    DeletedModules = [];

    /* Write all modules */
    maplist(string m, map modmap, Modules, ``{
	string modul = modmap["module"]:"";
	string options = modmap["options"]:"";

	/* Write module alias */
	if(modul != nil && modul != "")
	    // y2debug("%1 %2", add(.modules.alias, m), modul);
	    SCR::Write(add(.modules.alias, m), modul);

	/* Create module options map */
	list optslist = filter(string s, splitstring(options, " "), ``(s != ""));
	map optsmap = listmap(string opt, optslist, ``{
	    list tok = splitstring(opt, "=");
	    return [ tok[0]:"", tok[1]:"" ];
	});

	/* Write module options */
	if(size(optsmap) > 0)
	    // y2milestone("%1 %2", add(.modules.options, m), optsmap);
	    SCR::Write(add(.modules.options, m), optsmap);

	/* FIXME: s390 modules hack */
	if(false) {
	    /* write module options */
	    if(size(opts_map) > 0) {
		/* write module options normally */
		if(!Arch::s390)
		    SCR::Write(.modules.options, opts_map, dev);
		else {
		    /* merge module options */
		    if(typ == "iucv") {
			map curopts = SCR::Read(.modules.options, "netiucv");
			maplist(`k, `v, opts_map, ``{
			    if(haskey(curopts, k))
				change(curopts, k, curopts[k]:"" + ":" + v);
			    else
				change(curopts, k, v);
			});
			SCR::Write(.modules.options, curopts, "netiucv");
		    }
		    /* write options to chandev.conf */
		    else {
			path chandev = topath(".etc.chandev_conf."+mod+num);
			if(typ == "escon") chandev = topath(".etc.chandev_conf.escon"+num);
			y2milestone("Write(%1,%2)", chandev, opts);
			SCR::Write(chandev, opts);
		    }
		}
	    }
	}

    });

    /* Finish him */
    SCR::Write(.modules, nil);

    return true;
}

/**
 * Update Modules map
 * @param name device name
 * @param check if check if module already exists
 * @return true if success
 */
global define boolean ChangeModule(string name, boolean check) ``{
    y2debug("Module=%1", Module);
    y2debug("Modules=%1", Modules);

    if(check && haskey(Modules, name)) {
	y2warning("Key already present: %1", name);
	/* Change it always and report only warning: return false; */
    }

    map modmap = $[];
    maplist(string dir, string val, Module, ``{
	if(val != nil && val != "") change(modmap, dir, val);
    });
    y2debug("%1 -> %2", name, modmap);
    change(Modules, name, modmap);

    y2debug("Modules=%1", Modules);
    return true;
}

/**
 * Delete a module from Modules map
 * @param name device name
 * @return true if success
 */
global define boolean DeleteModule(string name) ``{
    y2debug("Modules=%1", Modules);
    y2debug("DeletedModules=%1", DeletedModules);

    if(!haskey(Modules, name)) {
	y2error("Module not found: %1", name);
	return false;
    }

    map modmap = Modules[name]:$[];
    modmap = remove(modmap, "options");
    change(Modules, name, modmap);
    change(DeletedModules, name);

    y2debug("Modules=%1", Modules);
    y2debug("DeletedModules=%1", DeletedModules);
    return true;
}

/**
 * Locate modules of the given type and value
 * @param key module key
 * @param val module value
 * @return list of modules with key=val
 */
global define list LocateModules(string key, string val) ``{
    list ret = [];
    maplist(string typ, map devsmap, Modules, ``{
	maplist(string num, map devmap, devsmap, ``{
	    if(devmap[key]:"" == val) change(ret, typ+num);
	});
    });

    return ret;
}

/**
 * Add a new kernel module
 * @param type added module type
 * @return true on success
 */
global define boolean AddModule(string type) ``{

    y2debug("Add(%1)", type);
    if(type == nil) {
	y2error("Invalid type: %1", type);
	return false;
    }

    /* FIXME: type dependent heuristics */

    Module["module"] = "";
    Module["options"] = "";
    return true;
}

/**
 * Select the given kernel module and fill internal variables
 * @param name module name
 * @return true on success
 */
global define boolean SelectModule(string name) ``{

    y2debug("Select(%1)", name);
    if(name != "" && !haskey(Modules, name)) {
	y2error("Invalid module: %1", name);
	return false;
    }

    Module["module"] = Modules[name, "module"]:"";
    Module["options"] = Modules[name, "options"]:"";
    y2debug("Select(module) = ", Module["module"]:"");
    y2debug("Select(options) = ", Module["options"]:"");

    return true;
}

/* EOF */
}
