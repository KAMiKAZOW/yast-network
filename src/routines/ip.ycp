/**
 * File:	include/network/ip.ycp
 * Module:	Network configuration library
 * Summary:	IP manipulation routines
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 */

{

textdomain "network";

/**
 * Check syntax of IPv4 address
 * @param ip IPv4 address
 * @return true if correct
 */
global define boolean check_ip4(string ip) ``{
    if (ip == nil || ip == "") return false;
    string num = "(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])";
    string ipv4 = "^" + num + "(\\." + num + "){3}$";
    return regexpmatch(ip, ipv4);
}

/**
 * Better check syntax of IPv4 address
 * @param ip IPv4 address
 * @return true if correct
 */
define boolean check_ip4_new(string ip) ``{
    if (ip == nil || ip == "") return false;
    string num0 = "(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[1-9])";
    string num1 = "(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])";
    string ipv4 = "^" + num0 + "(\\." + num1 + "){3}$";
    return regexpmatch(ip, ipv4);
}

/**
 * Check syntax of IPv6 address -- not yet finished
 * @param ip IPv6 address
 * @return true if correct
 */
global define boolean check_ip6(string ip) ``{
    if (ip == nil || ip == "") return false;
    string num = "([1-9a-fA-F][0-9a-fA-F]*|0)";
    string ipv6 = "^" + num + "(:" + num + "){7}$";
    return regexpmatch(ip, ipv6);
}

/**
 * Check the netmask -- still not finished?
 * Note that 0.0.0.0 is not a correct netmask.
 * @param netmask network mask
 * @return true if correct
 */
global define boolean check_netmask(string netmask) ``{
    string s1 = "(128|192|224|240|248|252|254|255)";
    string nm = "^(" + s1 + ".0.0.0|" + "255." + s1 + ".0.0|"
	+ "255.255." + s1 + ".0|" + "255.255.255." + s1 + ")$";
    return regexpmatch(netmask, nm);
}

/**
 * Convert IPv4 address from string to integer
 * @param ip IPv4 address
 * @return ip address as integer
 */
global define integer ip2integer(string ip) ``{
    /* FIXME: check_ip4, also to compute_* */
    /* if(size(l)!=4) return nil; */
    list l = maplist (`e, splitstring (ip, "."), ``(tointeger (e)));
    return select(l,3,0) + select(l,2,0)<<8 + select(l,1,0)<<16 + select(l,0,0)<<24;
}

/**
 * Convert IPv4 address from integer to string
 * @param ip IPv4 address
 * @return ip address as string
 */
global define string ip2string(integer ip) ``{
    list l = maplist (`b, [0x1000000, 0x10000, 0x100, 0x1], ``((ip / b) & 0xff));
    return sformat("%1.%2.%3.%4",select(l,0,0),select(l,1,0),select(l,2,0),select(l,3,0));
}

/**
 * Converts IPv4 address from string to hex format
 * @param ip IP address as string in "ipv4" format
 * @return string representing IP in Hex
 * @example ip2hex ("192.168.1.1") -> "0xC0A80101"
 */
global define string ip2hex(string ip) ``{
    return substring(toupper(tohexstring(ip2integer(ip))),2);
}

/**
 * Compute IPv4 network address from ip4 address and network mask.
 * @param ip IPv4 address
 * @param mask netmask
 * @return computed subnet
 */
global define string compute_network(string ip, string mask) ``{
    integer i = ip2integer(ip);
    integer m = ip2integer(mask);
    return ip2string((i & m) & 0xffffffff);
}

/**
 * Compute IPv4 broadcast address from ip4 address and network mask. The
 * broadcast address is the highest address of network address range.
 * @param ip IPv4 address
 * @param mask netmask
 * @return computed broadcast
 */
global define string compute_broadcast(string ip, string mask) ``{
    integer i = ip2integer(ip);
    integer m = ip2integer(mask);
    return ip2string((i | ~m) & 0xffffffff);
}

/* EOF */
}
