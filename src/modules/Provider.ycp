/**
 * File:	modules/Provider.ycp
 * Package:	Network configuration
 * Summary:	Provider data
 * Authors:	Dan Vesely <dan@suse.cz>
 *		Petr Blahos <pblahos@suse.cz>
 *		Michal Svec <msvec@suse.cz>
 *
 * $Id$
 */

{

module "Provider";
textdomain "network";

import "Language";
import "Summary";

include "network/routines.ycp";

/*------------------*/
/* GLOBAL VARIABLES */

/**
 * Abort function
 * return boolean return true if abort
 */
global block AbortFunction = nil;

/**
 * Current provider name
 */
global string Name = "";

/**
 * Current provider
 */
global map Provider = $[];

/*-----------------*/
/* LOCAL VARIABLES */

/**
 * Current provider type
 */
string Type = "modem";

/**
 * All providers type
 */
string GlobalType = "all";

/**
 * Supported provider types
 */
list Supported = [ "modem", "isdn", "dsl" ];

/**
 * Custom providers
 */
map Providers = $[];

/**
 * Custom providers (initial copy)
 */
map OriginalProviders = $[];

/**
 * Countries list
 */
list Countries = [];

/**
 * Deleted providers
 */
list Deleted = [];

/**
 * Pending operation (nil = none)
 */
symbol operation = nil;

/**
 * Dirty bit
 */
boolean modified = false;

/*------------------*/
/* GLOBAL FUNCTIONS */

/**
 * Were the providers changed?
 * @return true if modified
 */
global define boolean Modified() ``{
    return modified;
}

/**
 * Read providers data (custom only) and country mappings
 * @param type providers the module is working with ("all"|"modem"|"isdn"|"dsl")
 * @return true if success
 */
global define boolean Read(string type) ``{

    boolean ret = true;

    /* Save the providers type for future use */
    if(type != "all" && !contains(Supported, type)) {
	y2error("Unsupported provider type: %1", type);
	GlobalType = "all";
    }
    else
	GlobalType = type;

    if(GlobalType != "all")
	Type = type;

    y2debug("GlobalType=%1", GlobalType);
    y2debug("Type=%1", Type);

    /* Read custom providers */
    Providers = $[];
    list dir = SCR::Dir(.sysconfig.network.providers.s);

    /* Filter away backups (files with ~) */
    dir = filter(string file, dir, ``(!regexpmatch(file, "[~]")));

    /* Fill the Providers map */
    foreach(string name, dir, ``{
	path prov = add(.sysconfig.network.providers.v, name);
	map p = listmap(string i, SCR::Dir(prov), ``{
	    list ii = [];
	    change(ii, i);
	    change(ii, unquote(SCR::Read(add(prov, i))));
	    return ii;
	});
	change(Providers, name, p);
    });

    /* Filter out the current type */
    /* Read all providers -- we need them for checking uniqueness
    if(type != "all") {
	providers = filter(`k, `v, providers, ``{
	    y2debug("%1 %2",v["PROVIDER"]:"",v[toupper(type)+"SUPPORTED"]:"yes");
	    return v[toupper(type)+"SUPPORTED"]:"yes" == "yes";
	});
    }
    */

    /* Read countries */
    map country_names = SCR::Read(.target.yast2, "country.ycp");
    if(country_names == nil) {
	//Report:Error(_("Country database not found"));
	y2error("Country database not found");
	country_names = $[];
	ret = false;
    }
    textdomain "country";
    country_names = eval(country_names);
    textdomain "network";

    /* Local language heuristics */
    string language = Language::GetLanguageCountry();
    y2debug("language=%1", language);

    /* Initialize the countries selection box */
    Countries = [];
    integer index = -1;
    Countries = SCR::Dir(.providers.s);
    y2debug("Countries=%1", Countries);
    if(!contains(Countries, language)) language = "CZ";
    Countries = maplist(string i, Countries, ``{
	index = index + 1;
	return `item(`id(i), country_names[i]:i, i == language);
    });
    y2debug("Countries=%1", Countries);

    /* Read system providers */
    /* Slow -- better read them upon request (SelectSystem)
    map P = $[];
    P = listmap(string cs, SCR::Dir(.providers.s), ``{
	path pp = add(.providers.s, cs);
	// y2debug("--- (%1), %2 ---", pp, SCR::Dir(pp));
	return [ cs, listmap(string c, SCR::Dir(pp), ``{
	    pp = add(add(.providers.v, cs), c);
	    // y2debug("--- %1 ---", SCR::Dir(pp));
	    return [ c,
	    listmap(string vs, SCR::Dir(pp), ``{
		// y2debug("%1=%2", vs, SCR::Read(add(pp, vs)));
		return [ vs, SCR::Read(add(pp, vs)) ];
	    }) ];
	}) ];
    });
    */

    return ret;
}

/**
 * Write custom providers data
 * @return true if sucess
 */
global define boolean Write() ``{

    boolean ret = true;

    /* Check for changes */
    if(Providers == OriginalProviders) {
	y2debug("No changes -> not writing");
	return true;
    }

    /* Remove deleted custom providers */
    maplist(string provider, Deleted, ``{
	path p = add(.sysconfig.network.providers.section, provider);
	y2debug("deleting: %1", p);
	SCR::Write(p, nil);
    });
    Deleted = [];

    /* Write custom providers */
    foreach(string name, map provider, Providers, ``{

	name = filterchars(name, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-.");
	path base = add(.sysconfig.network.providers.v, name);

	/* Ensure all neccesary items are present */
	if(!haskey(provider, "MODEMSUPPORTED"))
	    change(provider, "MODEMSUPPORTED", "yes");
	if(!haskey(provider, "ISDNSUPPORTED"))
	    change(provider, "ISDNSUPPORTED", "no");
	if(!haskey(provider, "DSLSUPPORTED"))
	    change(provider, "DSLSUPPORTED", "no");

	/* Write all values */
	foreach(string k, string v, provider, ``{

	    /* Adjust some values */
	    if(k == "ASKPASSWORD" || k == "STUPIDMODE" || k == "COMPUSERVE" ||
		    k == "ISDNSUPPORTED" || k == "DSLSUPPORTED" ||
		    k == "MODEMSUPPORTED") {
		if(v == "0") v = "no";
		else if(v == "1") v = "yes";
		else if(v != "no" && v != "yes")
		    v = (find(v, "no") != -1 ? "no" : "yes");
	    }

	    /* Do the write */
	    SCR::Write(add(base, k), quote(v));
	});
    });

    /* Flush */
    SCR::Write(.sysconfig.network.providers, nil);

    /* Change the rights (provider can contain password #13353 */
    SCR::Execute(.target.bash, "/bin/chown -R root:root /etc/sysconfig/network/providers");
    SCR::Execute(.target.bash, "/bin/chmod -R 0600 /etc/sysconfig/network/providers");
    SCR::Execute(.target.bash, "/bin/chmod 0700 /etc/sysconfig/network/providers");

    return ret;
}

/**
 * Import data
 * @param providers providers to be imported
 * @return true on success
 */
global define map Import(map providers) ``{
    Name = "";
    Provider = $[];
    Providers = eval(providers);
    modified = true;
}

/**
 * Export data
 * @return dumped settings (later acceptable by Import())
 */
global define map Export() ``{
    return eval(Providers);
}

/**
 * Select the given system provider
 * @param name SCR path to the system provider
 * @return true if success
 */
global define boolean SelectSystem(path name) ``{

    y2debug("name=%1", name);

    Name = sformat("%1", name);
    if(findlastof(Name, ".") != -1)
	Name = regexpsub(Name, "^.*\\.([^.]*)", "\\1");
    if(Name == nil) Name = "";

    if("\"" == substring(Name, 0, 1))
	Name = substring(Name, 1, size(Name) - 2);

    list values = SCR::Dir(name);
    Provider = listmap(string value, values, ``{
	return [ value, SCR::Read(add(name, value)) ];
    });

    y2debug("Name=%1", Name);
    y2debug("Provider=%1", Provider);

    return true;
}

/**
 * Select the given provider
 * @param name provider to select ("" for new provider, default values)
 * @return true if success
 */
global define boolean Select(string name) ``{

    Name = "";
    Provider = $[];

    y2debug("name=%1", name);
    if(name != "" && !haskey(Providers, name)) {
	y2error("No such provider: %1", name);
	return false;
    }

    Name = name;
    Provider = eval(Providers[Name]:$[]);
    Type = CurrentType();

    if(Provider == $[]) {
	/* Default provider map */
	Provider = $[
	    /* FIXME: remaining items */
	];

	/* Variable key -> not functional #16701 */
	change(Provider, toupper(Type) + "SUPPORTED", "yes");
    }

    y2debug("Name=%1", Name);
    y2debug("Type=%1", Type);
    y2debug("Provider=%1", Provider);

    return true;
}

/**
 * Add a new provider
 * @param type provider type (modem|isdn|dsl)
 * @return true if success
 */
global define boolean Add(string type) ``{
    operation = nil;
    if(!contains(Supported, type)) {
	y2error("Unsupported provider type: %1", type);
	return false;
    }
    Type = type;
    if(Select("") != true) return false;
    if(CloneProvider() != true) return false;
    operation = `add;
    return true;
}

/**
 * Edit the given provider
 * @param name provider to edit
 * @return true if success
 */
global define boolean Edit(any name) ``{
    operation = nil;
    Type = "";
    if(Select(name) != true) return false;
    operation = `edit;
    return true;
}

/**
 * Delete the given provider
 * @param name provider to delete
 * @return true if success
 */
global define boolean Delete(string name) ``{
    operation = nil;

    y2debug("Delete(%1)", name);
    if(!haskey(Providers, name)) {
	y2error("Key not found: %1", name);
	return false;
    }

    Name = name;
    operation = `delete;
    return true;
}

/**
 * Commit pending operation
 * @return true if success
 */
global define boolean Commit() ``{
    y2debug("Commit(%1)", operation);

    if(operation == `add || operation == `edit) {
	y2debug("Providers=%1", Providers);
	change(Providers, Name, Provider);
	y2debug("Providers=%1", Providers);
    }
    else if(operation == `delete) {
	if(!haskey(Providers, Name)) {
	    y2error("Key not found: %1", Name);
	    return false;
	}
	Providers = remove(Providers, Name);
	change(Deleted, Name);
    }
    else {
	y2error("Unknown operation: %1 (%2)", operation, Name);
	return false;
    }

    Name = "";
    Type = "";
    Provider = $[];
    modified = true;
    operation = nil;
    return true;
}

/**
 * Clone the given provider
 * @param name provider to clone
 * @return true if success
 */
global define boolean Clone(string name) ``{
    operation = nil;
    if(Select(name) != true) return false;
    if(CloneProvider() != true) return false;
    operation = `add;
    return true;
}

/**
 * Clone the given system provider
 * @param name SCR path to system provider to clone
 * @return true if success
 */
global define boolean CloneSystem(path name) ``{
    operation = nil;
    if(SelectSystem(name) != true) return false;
    if(CloneProvider() != true) return false;
    operation = `add;
    return true;
}

/**
 * Clone current provider
 * @return true if success
 */
define boolean CloneProvider() ``{

    string fullname = Provider["PROVIDER"]:"";
    y2debug("fullname=%1", fullname);

    /* Split possible (1) from the end */
    if(regexpmatch(fullname, " \\([0-9]+\\)$")) {
	fullname = regexpsub(fullname, "(.*) \\([0-9]+\\)$", "\\1");
	y2debug("fullname=%1", fullname);
    }

    /* Generate unique full name (Provider["PROVIDER"]) */
    integer suffix = 0;
    string gen = fullname;
    list forbidden = maplist(string k, map v, Providers, ``(v["PROVIDER"]:""));
    while(contains(forbidden, gen)) {
	suffix = suffix + 1;
	gen = sformat("%1 (%2)", fullname, suffix);
    }
    Provider["PROVIDER"] = gen;
    y2debug("fullname=%1", gen);

    /* Generate unique Name */
    suffix = 0;
    string name = Name;
    y2debug("Name=%1", Name);

    /* Split possible number from the end */
    if(regexpmatch(name, "[0-9]+$")) {
	name = regexpsub(name, "(.*)[0-9]+", "\\1");
	y2debug("name=%1", name);
    }

    /* Sensible defaults for new providers */
    gen = name;
    if(gen == "") {
	gen = "provider0";
	name = "provider";
    }
    if(gen == "provider")
	gen = "provider0";

    /* Generate unique name (Name) */
    forbidden = mapkeys(Providers);
    while(contains(forbidden, gen)) {
	suffix = suffix + 1;
	gen = sformat("%1%2", name, suffix);
    }
    Name = gen;
    y2debug("Name=%1", Name);

    return true;
}

/**
 * Create an overview table with all configured providers
 * @return table items
 */
global define list Overview() ``{
    list overview = [];

    y2debug("Providers=%1", Providers);
    maplist(string name, map provmap, Providers, ``{
	/* Filter only specified type */
	if(GlobalType == "all" || provmap[toupper(GlobalType)+"SUPPORTED"]:"no" == "yes") {
	    // change(overview, `item(`id(name), name, provmap["PROVIDER"]:"", provmap["PHONE"]:"", provmap["MODEMSUPPORTED"]:"no", provmap["ISDNSUPPORTED"]:"no", provmap["DSLSUPPORTED"]:"no"));
	    term it = `item(`id(name), name, provmap["PROVIDER"]:"");
	    if(GlobalType != "dsl") it = add(it, provmap["PHONE"]:"");
	    change(overview, it);
	}
    });
    y2debug("overview=%1", overview);

    return overview;
}

/**
 * Create a textual summary and a list of unconfigured providers
 * @param split split configured and unconfigured?
 * @return summary of the current configuration
 */
global define list Summary(boolean split) ``{

    string summary = "";
    if(size(Providers) < 1)
	/* Summary text */
	summary = Summary::AddHeader("", _("Nothing is configured."));
    else
	/* Summary text */
	summary = Summary::AddHeader("", _("Already configured providers:"));

    list provs = [];
    maplist(string name, string provmap, Providers, ``{
	/* Summary text description (%1 is provider name) */
	string descr = sformat(_("Configured as %1"), name);
	string phone = provmap["PHONE"]:"";
	if(phone != "" && phone != nil)
	    /* Summary text description (%1 is provider name) */
	    descr = sformat(_("Configured as %1 (phone %2)"), name, phone);
	change(provs, Summary::Device(provmap["PROVIDER"]:"", descr));
    });
    summary = Summary::DevicesList(provs);

    return [
	summary,
	[
	    /* List item to providers summary */
	    `item(`id("modem"), _("Modem provider"), true),
	    /* List item to providers summary */
	    `item(`id("isdn"), _("ISDN Provider")),
	    /* List item to providers summary */
	    `item(`id("dsl"), _("DSL Provider")),
	]
    ];
}

/**
 * Get list of countries
 * @return list for SelectionBox
 */
global define list GetCountries() ``{
    return Countries;
}

/**
 * Check if provider name is unique
 * @param name provider name
 * @return true if OK
 */
global define boolean IsUnique(string name) ``{
    list forbidden = maplist(string k, string v, Providers, ``(v["PROVIDER"]:""));
    return !contains(forbidden, name);
}

/**
 * Return current provider type
 * @return current provider type
 */
global define string CurrentType() ``{
    y2debug("Type=%1", Type);
    y2debug("GlobalType=%1", GlobalType);
    if(Type != "") return Type;
    list supp = filter(string t, Supported, ``(Provider[toupper(t+"SUPPORTED")]:"no" == "yes"));
    y2debug("supp=%1", supp);
    if(size(supp) < 1) {
	if(GlobalType != "all") return GlobalType;
	y2error("None supported type: %1", Provider);
	return "";
    }
    return supp[0]:"";
}

/*-------------------------------------------------------------------*/
/* FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME */
/*-------------------------------------------------------------------*/

/**
 * Filter providers based on the type
 * @param provs list of providers
 * @param type desired type "modem"|"isdn"|"rawip"|"syncppp"|"dsl"
 * @return list of type capable providers
 */
define list FilterProviders(list provs, string type) ``{
    y2debug("provs,type=%1,%2", provs, type);
    string supported = toupper(type) + "SUPPORTED";
    boolean etst = false;
    if (type == "rawip" || type == "syncppp") {
	supported = "ISDNSUPPORTED";
	etst = true;
    }
    y2debug("supported=%1", supported);

    return filter(`i, provs, ``{
	y2debug("i=%1", i);
	if(is(i, string)) {
	    map p = Providers[i]:$[];
	    if(p[supported]:"no" == "yes")
		if (etst)
		    return p["ENCAP"]:"_nodef" == type;
		else
		    return true;
	    else
		return false;
	}
	else if(SCR::Read(i + topath("."+supported)) == "yes")
	    if (etst)
		return (SCR::Read(i + topath(".ENCAP")) == type);
	    else
		return true;
	else
	    return false;
    });
}

/**
 * Get providers from a group (country/other)
 * @param country we want providers from this country
 * @param preselect preselect this provider
 * @return list of items for SelectionBox
 */
global define list GetProviders(string country, string preselect) ``{
    list provs = [];

    y2debug("%1-%2", country, preselect);
    /* Custom providers */
    if(country == "_custom") {
	foreach(string k, map v, Providers, ``{
	    change(provs, k);
	});
    }
    /* Providers from given country */
    else {
	list dir = SCR::Dir(add(.providers.s, country));
	path base = add(.providers.v, country);
	provs = maplist(string i, dir, ``{
	    return add(base, i);
	});
    }

    y2debug("Type=%1", Type);
    y2debug("provs=%1", provs);
    /* Filter only desired providers */
    provs = FilterProviders(provs, Type);

    y2debug("provs=%1",provs);
    /* Sort and create divider (line) */
    provs = SortProviders(provs);

    y2debug("provs=%1",provs);
    integer index = -1;
    /* i is either string or path */
    return maplist(any i, provs, ``{
	index = index + 1;
	if(is(i, string))
	    return `item(`id(i), lookup(Providers[i]:$[], "PROVIDER", i), index == 0 || preselect == i);
	else
	    if(."--" == i)
		return `item(`id(i), "----------------");
	    else
		return `item(`id(i), SCR::Read(i + .PROVIDER), 0 == index);
    });
}

/**
 * Sorts providers alphabeticly (non-case-sensitivly) and by priority.
 * In the first step, priority and name of each provider is obtained.
 * List of strings built from these values is created. Item lists are:
 * "<1-character-priority><34-characters-provider-name><provider-identifier>"
 * This list is sorted, result is correctly sorted, by priority and
 * alphabeticly. I did not use builtin sort with sort code because it
 * uses bubble sort -- it was bloody slow.
 * @param provs list of providers
 * @return sorted list of providers
 */
define list SortProviders(list provs) ``{
    list pre = sort(maplist(any i, add(provs, "--"), ``{
	if("--" == i)
	    return "9                                  .\"--\"";
	if(is(i, string))
	    return "x                                  " + i;
	else {
	    string tmp = SCR::Read(i + .PRIORITY);
	    if(nil == tmp)
		tmp = "-1";
	    integer p = 8 - tointeger(tmp);
	    if(p < 0 || p > 9)
		y2error("Wrong priority (%1), you must change the algorithm! [%2]", p, tmp);
	    tmp = tolower(SCR::Read(i + .PROVIDER)) + "                                   ";
	    tmp = sformat("%1", p) + tmp;
	    return sformat("%1%2", substring(tmp, 0, 35), i);
	}
    }));
    if(".\"--\"" == substring(pre[0]:"", 35))
	pre = remove(pre, 0);
    return maplist(string i, pre, ``{
	if("x" == substring(i, 0, 1))
	    return substring(i, 35);
	return topath(substring(i, 35));
    });
}

/* EOF */
}
