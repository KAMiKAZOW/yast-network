/**
 * File:	modules/Proxy.ycp
 * Package:	Network configuration
 * Summary:	Proxy data
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 *
 * Configures FTP and HTTP proxies via sysconfig & SuSEconfig
 * and /root/.curlrc (for YOU)
 */

{

module "Proxy";
textdomain "network";

import "Summary";

include "network/routines.ycp";
include "network/runtime.ycp";

global boolean proposal_valid = false;
global boolean write_only = false;

/**
 * Data was modified?
 */
global boolean modified = false;

global boolean enabled = false;
global string http = "";
global string ftp = "";
global string no = "";
global string user = "";
global string pass = "";


/**
 * Read settings
 * @return true if success
 */
global define boolean Read() {

    /* Read /etc/sysconfig/proxy */
    http = (string) SCR::Read(.sysconfig.proxy.HTTP_PROXY);
    if(http == nil) http = "";
    ftp = (string) SCR::Read(.sysconfig.proxy.FTP_PROXY);
    if(ftp == nil) ftp = "";
    no = (string) SCR::Read(.sysconfig.proxy.NO_PROXY);
    if(no == nil) no = "";
    enabled = (string) SCR::Read(.sysconfig.proxy.PROXY_ENABLED) != "no";

    /* Read /root/.curlrc */
    if(SCR::Read(.target.size, "/root/.curlrc") > 0)
	user = (string) SCR::Read(.root.curlrc.proxy-user);

    if(user == nil) user = "";

    if(issubstring(user, ":")) {
	pass = regexpsub(user, "^.*:(.*)$", "\\1");
	user = regexpsub(user, "^(.*):.*$", "\\1");
    }
    if(pass == nil) pass = "";
    if(user == nil) user = "";

    /* Read /root/.wgetrc */
    /* YOU uses curl(1)
    user = SCR::Read(.root.wgetrc.proxy_user);
    if(user == nil) user = "";
    pass = SCR::Read(.root.wgetrc.proxy_passwd);
    if(pass == nil) pass = "";
    */

    return true;
}

/**
 * Write routing settings and apply changes
 * @return true if success
 */
global define boolean Write() {

    y2milestone("Writing configuration");
    if(!modified) {
	y2milestone("No changes to proxy configuration -> nothing to write");
	return true;
    }

    /* Update /etc/sysconfig/proxy */
    SCR::Write(.sysconfig.proxy.PROXY_ENABLED, enabled?"yes":"no");
    SCR::Write(.sysconfig.proxy.HTTP_PROXY, http);
    SCR::Write(.sysconfig.proxy.FTP_PROXY, ftp);
    SCR::Write(.sysconfig.proxy.NO_PROXY, no);
    SCR::Write(.sysconfig.proxy, nil);

    /* Update /root/.curlrc */
    string proxyuser = nil;
    if(user != "") {
	proxyuser = user;
	if(pass != "") proxyuser = user + ":" + pass;
    }
    SCR::Write(.root.curlrc.proxy-user, proxyuser);
    SCR::Write(.root.curlrc.proxy-user.comment, ChangedComment("proxy"));
    SCR::Write(.root.curlrc, nil);

    /* Update /root/.wgetrc */
    /* YOU uses curl(1)
    SCR::Write(.root.wgetrc.proxy_user, user);
    SCR::Write(.root.wgetrc.proxy_passwd, pass);
    SCR::Write(.root.wgetrc, nil); */

    /* Update profiles generated by SuSEconfig */
    RunSuSEconfigModule("profiles");
    modified = false;

    return true;
}


/**
 * Get all settings from a map.
 * When called by <name>_auto (preparing autoinstallation data)
 * the map may be empty.
 * @param settings autoinstallation settings
 * @return true if success
 */
global define boolean Import(map settings) {
    enabled = settings["enabled"]:false;
    http = settings["http_proxy"]:"";
    ftp = settings["ftp_proxy"]:"";
    no = settings["no_proxy"]:"localhost";
    user = settings["proxy_user"]:"";
    pass = settings["proxy_password"]:"";

    modified = true;
    return true;
}

/**
 * Dump the Routing settings to a map, for autoinstallation use.
 * @return autoinstallation settings
 */
global define map Export() {
    map settings = $[
	"enabled"	: enabled,
	"http_proxy"	: http,
	"ftp_proxy"	: ftp,
	"no_proxy"	: no,
	"proxy_user"	: user,
	"proxy_password": pass,
    ];
    return settings;
}

/**
 * Create proxy summary
 * @return summary text
 */
global define string Summary() {

    list<string> ret = [];

    /* Summary text */
    if(!enabled) ret = [ Summary::Device(_("Proxy is disabled."), "") ];

    else {

	/* Summary text */
	ret = [ Summary::Device(_("Proxy is enabled."), "" +
	/* Summary text */
	(http != "" ? sformat(_("HTTP Proxy: %1") + "<br>", http):"" ) +
	/* Summary text */
	(ftp != "" ? sformat(_("FTP Proxy: %1") + "<br>", ftp):"" ) +

	"" )];

	    /* Summary text * /
	    Summary::Device(sformat(_("No Proxy Domains: %1"), no) + "\n<br>" +
	    "<p>" + ( user == "" ?
		/* Summary text * /
		_("Proxy user name is not set.") :
		/* Summary text * /
		sformat(_("Proxy User Name: %1"), user)) +
	    "<br>" + ( pass == "" ?
		/* Summary text * /
		_("Proxy password is not set.") :
		/* Summary text * /
		_("Proxy password is set.")) ];
		*/
    }

    return Summary::DevicesList(ret);
}

/**
 * Function which returns if the settings were modified
 * @return boolean  settings were modified
 */
global define boolean GetModified () {
    return modified;
}
/**
 * Function sets internal variable, which indicates, that any
 * settings were modified, to "true"
 */
global define void SetModified () {
    modified = true;
}

/**
 * Function returns an environment usable for curl.
 */
global define map <string, string> GetEnvironment ()
{
    if (!enabled)
	return $[];

    if (!modified)
	Read ();

    return $[
	     "http_proxy"	: http,
	     "FTP_PROXY"	: ftp,
	     "NO_PROXY"		: no
    ];
}

/* EOF */
}
