/**
 * File:
 *   modules/Providers.ycp
 *
 * Package:
 *   Configuration of network
 *
 * Summary:
 *   Providers dialogs
 *
 * Authors:
 *   Dan Vesely <dan@suse.cz>
 *   Petr Blahos <pblahos@suse.cz>
 *   Michal Svec <msvec@suse.cz>
 *
 * $Id$
 *
 * Dialogs and functions for Providers.
 *
 */

{

module "Providers";

textdomain "network";

import "DSL";
import "Modem";
import "ISDN";

/**
 * Modem we are currently working with.
 * Members for dialup - phone provider:
 * "DialMessage1" :
 * "DialMessage2" :
 * "Provider" : nice name of provider
 * "ShortName" : short name of provider (name of the section in *.conf)
 * "Username" :
 * "Password" :
 * "Ask Password" : "no" or "yes"
 * "Phone" : the most important - phone number
 * "DNS1" : first dns
 * "DNS2" : second dns
 *
 * Members for isdn provider:
 * "DialMessage1" :
 * "DialMessage2" :
 * "Provider" : nice name of provider
 * "ShortName" : short name of provider (name of the section in *.conf)
 * "Username" :
 * "Password" :
 * "Phone" : the most important - phone number
 * "I4L_ENCAP" : encapsulation but who knows what it means
 */
global map provider = $[];

/**
 * Dirty bit
 */
boolean dirty = false;


/**
 * Custom providers.
 */
map providers = $[];

/* provider settings */
global string provShortName = "";
global string provLongName = "";

/**
 * Country code -> country name translation
 */
map country = $[];

/**
 * 2 character country id --> country nice name mapping.
 */
map country_nice_name = nil;

/**
 * Get nice name of country.
 * @param fn file name from which we take the country
 * @return nice name of the country
 */
define string getCountryNiceName (string fn) ``{
    if (nil == country_nice_name)
    {	// First time, read mapping.
	country_nice_name = SCR::Read (.target.yast2, "country.ycp");
	textdomain "country_db";
	country_nice_name = eval (country_nice_name);
	textdomain "network";
	if (nil == country_nice_name)
	    country_nice_name = $[];
    }
    // "/usr/share/providers/XX....";
    if ("/usr/share/providers/" == substring (fn, 0, 21))
	fn = substring (fn, 21, 2);
    if ("UK" == fn)
	fn = "GB";
    return lookup (country_nice_name, fn, fn);
}

/**
 * Export data
 */
global define map Export () ``{
    return providers;
}

/**
 * Import data
 */
global define map Import (map in) ``{
    providers = in;
    provider = $[];
    dirty = true;
}

/**
 * were the providers changed?
 */
global define boolean Modified () ``{
    return dirty;
}

/**
 * Most probably it means to check if section name in .conf is
 * unque.
 */
global define boolean IsSectionUnique (string name) ``{
    list forbidden = maplist (`k, `v, providers, ``( k ));
    return !contains (forbidden, name);
}

/**
 * Most probably it means to check if provider name in .conf is
 * unque.
 */
global define boolean IsProviderUnique (string name) ``{
    list forbidden = maplist (`k, `v, providers, ``( lookup (v, "PROVIDER", "")));
    return !contains (forbidden, name);
}

/**
 * Prepare for editation of currently selected provider.
 * Check/change its name (ShortName) and nice-name
 * (Provider) to unused.
 * @param prov_id provider to edit
 */
global define void editProvider (any prov_id) ``{
    if (is (prov_id, string)) //User chose provider from "Other" -- edit it.
	return ;
    integer suffix = 0;
    string name = lookup (provider, "ShortName", "");
    string gen = name;
    list forbidden = maplist (`k, `v, providers, ``( k ));
    while (contains (forbidden, gen))
    {
	suffix = suffix + 1;
	gen = sformat ("%1%2", name, suffix);
    }
    provider = add (provider, "ShortName", gen);

    name = lookup (provider, "PROVIDER", "");
    gen = name;
    suffix = 0;
    forbidden = maplist (`k, `v, providers, ``( lookup (v, "PROVIDER", "")));
    while (contains (forbidden, gen))
    {
	suffix = suffix + 1;
	gen = sformat ("%1 (%2)", name, suffix);
    }
    provider = add (provider, "PROVIDER", gen);
    // initialize provider with new values
    provider = union ($[
	    "AUTODNS" : "yes",
	    "IDLETIME" : "300",
	    "DEMAND" : "no",
	    "DNS1" : "",
	    "DNS2" : "", ],
	    provider);
}

/**
 * Add currently edited provider to the map of custom providers.
 * Copy settings to Modem::something
 */
global define void Commit () ``{
    dirty = true;
    providers = add (providers, lookup (provider, "ShortName", ""), provider);
    provShortName = lookup (provider, "ShortName", "");
    provLongName = lookup (provider, "PROVIDER", "");
}

/**
 * Read providers data
 * @return true if success
 */
global define boolean Read () ``{

    /* read custom providers */
    providers = $[];
    list dir = SCR::Dir(.custom_providers.s);
    foreach (`i, dir, ``{
	map p = getProvider (add (.custom_providers.v, i));
	integer slash = findlastof (i, "/");
	string shortname = nil == slash ? i : substring (i, slash + 1);
	p = add (p, "ShortName", shortname);
	providers = add (providers, shortname, p);
    });

    /* read countries */
    country = SCR::Read(.target.yast2, "country.ycp");
    if(country == nil) {
	//Report:Error(_("Countries database not found"));
	return false;
    }

    return true;
}

/**
 * Ensure all neccesary items are present.
 * @param prov provider map
 * @return new provider map with all entries
 */
define map completeProvider (map prov) ``{
    if (!haskey (prov, "MODEMSUPPORTED"))
	prov = add (prov, "MODEMSUPPORTED", "yes");
    if (!haskey (prov, "ISDNSUPPORTED"))
	prov = add (prov, "ISDNSUPPORTED", "no");
    if (!haskey (prov, "DSLSUPPORTED"))
	prov = add (prov, "DSLSUPPORTED", "no");
    return prov;
}

/**
 * Save custom providers into /etc/sysconfig/network/providers/
 * To change placement of the file of custom providers, edit it here
 * and in providers.scr!!!!!
 */
global define void Write () ``{
    foreach (`key, `value, providers, ``{
	string sname = lookup (value, "ShortName", "other");
	sname = filterchars (sname, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-.");
	path base = add (.custom_providers.v, sformat ("/etc/sysconfig/network/providers/%1", sname));
	foreach (`k, `v, completeProvider (value), ``{
	    // adjust some values
	    if ("ASKPASSWORD" == k || "STUPIDMODE" == k || "COMPUSERVE" == k || "ISDNSUPPORTED" == k || "DSLSUPPORTED" == k || "MODEMSUPPORTED" == k)
	    {
		if ("0" == v)		v = "no";
		else if ("1" == v)	v = "yes";
		else if ("no" != v && "yes" !=v)
		    v = (-1 != find (v, "no") ? "no" : "yes");
	    }
	    if ("ShortName" != k)
		SCR::Write (add (base, k), v);
	});
    });
    SCR::Write (.custom_providers, nil);
    foreach (`key, `value, providers, ``{
	string sname = lookup (value, "ShortName", "other");
	SCR::Execute (.target.bash, "/bin/chown root:root /etc/sysconfig/network/providers/" + sname);
	SCR::Execute (.target.bash, "/bin/chmod 0600 /etc/sysconfig/network/providers/" + sname);
    });
}

/**
 * Get list of countries
 * @return list for selection box
 */
global define list getCountries () ``{
    list out = [];
    list countries = SCR::Dir (.providers.s);
    integer index = -1;
    out = maplist (`i, countries, ``{
	    index = index + 1;
	    return `item (`id (i), getCountryNiceName (i), 0 == index);
    });
    return out;
}

/**
 * Lets only DSL providers "go in"
 * @param provs list of providers
 * @return list of dsl capable providers
 */
define list filterDSL (list provs) ``{
    return filter (`i, provs, ``{
	if (is (i, string))
	{
	    return "yes" == lookup (lookup (providers, i, $[]), "DSLSUPPORTED", "no");
	}
	else if ("yes" == SCR::Read (i + ."DSLSUPPORTED"))
	    return true;
	return false;
    });
}
/**
 * Lets only modem providers "go in"
 * @param provs list of providers
 * @return list of modem capable providers
 */
define list filterModem (list provs) ``{
    return filter (`i, provs, ``{
	if (is (i, string))
	{
	    return "yes" == lookup (lookup (providers, i, $[]), "MODEMSUPPORTED", "no");
	}
	else if ("no" == SCR::Read (i + ."MODEMSUPPORTED"))
	    return false;
	return true;
    });
}
/**
 * Lets only isdn capable providers "go in"
 * @param provs list of providers
 * @return list of isdn capable providers
 */
define list filterIsdn (list provs) ``{
    return filter (`i, provs, ``{
	if (is (i, string))
	{
	    return "yes" == lookup (lookup (providers, i, $[]), "ISDNSUPPORTED", "no");
	}
	else if ("yes" == SCR::Read (i + ."ISDNSUPPORTED"))
	    return true;
	return false;
    });
}

/**
 * Get providers from a group (country/other)
 * @param country we want providers from this country
 * @param type `isdn, `tdsl, `adsl, `anything_else
 * @param preselect preselect this provider
 */
global define list getProviders (string country, symbol type, string preselect) ``{
    list provs = [];
    if ("_custom" == country) {
	// custom providers
	foreach (`k, `v, providers, ``{
	    provs = add (provs, k);
	});
    }
    else {
	list dir = SCR::Dir (add (.providers.s, country));
	path base = add (.providers.v, country);
	provs = maplist (`i, dir, ``{
	    return add (base, i);
	});
    }

    // filter providers
    if (`isdn == type)
	provs = filterIsdn (provs);
    else if (`tdsl == type || `adsl == type)
	provs = filterDSL (provs);
    else
	provs = filterModem (provs);

    // sort and create divider (line)
    provs = sortProviders (provs);

    integer index = -1;
    return maplist (`i, provs, ``{
	index = index + 1;
	if (is (i, string))
	    return `item (`id (i), lookup (lookup (providers, i, $[]), "PROVIDER", i), 0 == index || preselect == i);
	else
	    if (."--" == i)
		return `item (`id (i), "----------------");
	    else
		return `item (`id (i), SCR::Read (i + .PROVIDER), 0 == index);
    });
}

/**
 * Read all provider keys from ini file to map.
 * Adds also key "ShortName" : "section_name";
 * @param provs list of providers
 * @return provider map
 */
global define map getProvider (any provider) ``{
    if (is (provider, path))
    {
	string pr = sformat ("%1", provider);
	integer pos = findlastof (pr, ".");
	if (-1 != pos)
	{
	    pr = substring (pr, pos + 1);
	    pr = substring (pr, 0, size (pr));
	    if ("\"" == substring (pr, 0, 1))
		pr = substring (pr, 1, size (pr) - 2);
	}
	list l = SCR::Dir (provider);
	return add (listmap (`i, l, ``{
	    return [ i, SCR::Read ( add (provider, i)) ];
	}), "ShortName", pr);
    }
    return lookup (providers, provider, $[]);
}

/**
 * Sorts providers alphabeticly (non-case-sensitivly) and by priority.
 * In the first step, priority and name of each provider is obtained.
 * List of strings built from these values is created. Item lists are:
 * "<1-character-priority><34-characters-provider-name><provider-identifier>"
 * This list is sorted, result is correctly sorted, by priority and
 * alphabeticly. I did not use builtin sort with sort code because it
 * uses bubble sort -- it was bloody slow.
 * @param provs list of providers
 * @return sorted list of providers
 */
define list sortProviders (list provs) ``{
    list pre = sort (maplist (`i, add (provs, "--"), ``{
	if ("--" == i)
	    return "9                                  .\"--\"";
	if (is (i, string))
	    return "x                                  " + i;
	else
	{
	    string tmp = SCR::Read (i + .PRIORITY);
	    if (nil == tmp)
		tmp = "-1";
	    integer p = 8 - tointeger (tmp);
	    if (p < 0 || p > 9)
		y2error ("======= wrong priority, you must change the algorithm!!! %1 =======", tmp);
	    tmp = tolower (SCR::Read (i + .PROVIDER)) + "                                   ";
	    tmp = sformat ("%1", p) + tmp;
	    return sformat ("%1%2", substring (tmp, 0, 35), i);
	}
    }));
    if (".\"--\"" == substring (select (pre, 0, ""), 35))
	pre = remove (pre, 0);
    return maplist (`i, pre, ``{
	if ("x" == substring (i, 0, 1))
	    return substring (i, 35);
	return topath (substring (i, 35));
    });
}

/* EOF */
}
