/**
 * File:	modules/Providers.ycp
 * Package:	Configuration of network
 * Summary:	Providers dialogs
 * Authors:	Dan Vesely <dan@suse.cz>
 *		Petr Blahos <pblahos@suse.cz>
 *		Michal Svec <msvec@suse.cz>
 *
 * $Id$
 *
 * Dialogs and functions for Providers.
 */

{

module "Providers";

textdomain "network";

import "DSL";
import "Modem";
import "ISDN";
import "Language";

include "network/routines.ycp";

/**
 * Modem we are currently working with.
 * Members for dialup - phone provider:
 * "DialMessage1" :
 * "DialMessage2" :
 * "Provider" : nice name of provider
 * "ShortName" : short name of provider (name of the section in *.conf)
 * "Username" :
 * "Password" :
 * "Ask Password" : "no" or "yes"
 * "Phone" : the most important - phone number
 * "DNS1" : first dns
 * "DNS2" : second dns
 *
 * Members for isdn provider:
 * "DialMessage1" :
 * "DialMessage2" :
 * "Provider" : nice name of provider
 * "ShortName" : short name of provider (name of the section in *.conf)
 * "Username" :
 * "Password" :
 * "Phone" : the most important - phone number
 * "ENCAP" : encapsulation but who knows what it means
 */
global map provider = $[];

/**
 * provider settings
 */
global string provShortName = "";
global string provLongName = "";

/**
 * Dirty bit
 */
boolean modified = false;

/**
 * Custom providers.
 */
map providers = $[];

/**
 * Countries list
 */
list countries = [];

list DELETED = [];
symbol operation = nil;
string name = "";
global block AbortFunction = nil;

/**
 * Export data
 * @return dumped settings (later acceptable by Import())
 */
global define map Export() ``{
    return providers;
}

/**
 * Import data
 * @param in settings to be imported
 * @return true on success
 */
global define map Import(map in) ``{
    providers = in;
    provider = $[];
    modified = true;
}

/**
 * Were the providers changed?
 * @return true if modified
 */
global define boolean Modified() ``{
    return modified;
}

/**
 * Most probably it means to check if section name in .conf is unique
 * @param name section name
 * @return true if OK
 */
global define boolean IsSectionUnique(string name) ``{
    list forbidden = mapkeys(providers);
    return !contains(forbidden, name);
}

/**
 * Most probably it means to check if provider name in .conf is unique
 * @param name provider name
 * @return true if OK
 */
global define boolean IsProviderUnique(string name) ``{
    list forbidden = maplist(`k, `v, providers, ``(v["PROVIDER"]:""));
    return !contains(forbidden, name);
}

/**
 * Read providers data (custom only) and country mappings
 * @return true if success
 */
global define boolean Read(string type) ``{

    boolean ret = true;

    /* read custom providers */
    providers = $[];
    list dir = SCR::Dir(.sysconfig.network.providers.s);
    // filter *~
    dir = filter(`file, dir, ``(!regexpmatch(file, "[\.~]")));
    foreach(`shortname, dir, ``{
	path prov = add(.sysconfig.network.providers.v, shortname);
	map p = listmap(`i, SCR::Dir(prov), ``{
	    return [ i, SCR::Read(add(prov, i)) ];
	});
	change(p, "ShortName", shortname);
	change(providers, shortname, p);
    });

    /* filter out the current type */
    if(type != "all") {
	providers = filter(`k, `v, providers, ``{
	    y2debug("%1 %2",v["PROVIDER"]:"",v[toupper(type)+"SUPPORTED"]:"yes");
	    return v[toupper(type)+"SUPPORTED"]:"yes" == "yes";
	});
    }

    /* read countries */
    map country_names = SCR::Read(.target.yast2, "country.ycp");
    if(country_names == nil) {
	//Report:Error(_("Country database not found"));
	y2error("Country database not found");
	country_names = $[];
	ret = false;
    }
    textdomain "country";
    country_names = eval(country_names);
    textdomain "network";

    /* local language heuristics */
    string language = Language::GetLanguageCountry();
    y2debug("language=%1", language);

    /* initialize the countries selection box */
    countries = [];
    integer index = -1;
    countries = SCR::Dir(.providers.s);
    y2debug("countries=%1",countries);
    if(!contains(countries, language)) language = "CZ";
    countries = maplist(`i, countries, ``{
	index = index + 1;
	return `item(`id(i), country_names[i]:i, i == language);
    });
    y2debug("countries=%1", countries);

    return ret;
}

/**
 * Write custom providers data
 * @return true if sucess
 */
global define boolean Write() ``{

    boolean ret = true;

    /* remove deleted custom providers */
    maplist(`d, DELETED, ``{
	path p = add(.sysconfig.network.providers.section, d);
	y2debug("deleting: %1", p);
	SCR::Write(p, nil);
    });

    /* write custom providers */
    foreach(`key, `value, providers, ``{
	string sname = lookup(value, "ShortName", "other");
	sname = filterchars(sname, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-.");
	path base = add(.sysconfig.network.providers.v, sname);
	foreach(`k, `v, completeProvider(value), ``{
	    // adjust some values
	    if("ASKPASSWORD" == k || "STUPIDMODE" == k || "COMPUSERVE" == k || "ISDNSUPPORTED" == k || "DSLSUPPORTED" == k || "MODEMSUPPORTED" == k)
	    {
		if("0" == v)		v = "no";
		else if("1" == v)	v = "yes";
		else if("no" != v && "yes" !=v)
		    v = (-1 != find(v, "no") ? "no" : "yes");
	    }
	    if("ShortName" != k)
		SCR::Write(add(base, k), v);
	});
    });
    SCR::Write(.sysconfig.network.providers, nil);

    /* change the rights (provider can contain password #13353  */
    SCR::Execute(.target.bash, "/bin/chown -R root:root /etc/sysconfig/network/providers");
    SCR::Execute(.target.bash, "/bin/chmod -R 0600 /etc/sysconfig/network/providers");
    SCR::Execute(.target.bash, "/bin/chmod 0700 /etc/sysconfig/network/providers");

    return ret;
}

/**
 * Ensure all neccesary items are present.
 * @param prov provider map
 * @return new provider map with all entries
 */
define map completeProvider(map prov) ``{
    if(!haskey(prov, "MODEMSUPPORTED"))
	prov = add(prov, "MODEMSUPPORTED", "yes");
    if(!haskey(prov, "ISDNSUPPORTED"))
	prov = add(prov, "ISDNSUPPORTED", "no");
    if(!haskey(prov, "DSLSUPPORTED"))
	prov = add(prov, "DSLSUPPORTED", "no");
    return prov;
}

/**
 * Get list of countries
 * @return list for SelectionBox
 */
global define list GetCountries() ``{
    return countries;
}

/**
 * Filter providers based on the type
 * @param provs list of providers
 * @param type desired type "modem"|"isdn"|"rawip"|"syncppp"|"dsl"
 * @return list of type capable providers
 */
define list FilterProviders(list provs, string type) ``{
    string supported = toupper(type) + "SUPPORTED";
    boolean etst = false;
    if (type == "rawip" || type == "syncppp") {
	supported = "ISDNSUPPORTED";
	etst = true;
    }
    y2debug("supported=%1",supported);

    return filter(`i, provs, ``{
	y2debug("i=%1", i);
	if(is(i, string)) {
	    map p = lookup(providers, i, $[]);
	    if (lookup(p, supported, "no") == "yes")
		if (etst)
		    return lookup(p, "ENCAP", "_nodef") == type;
		else
		    return true;
	    else
		return false;
	}
	else if(SCR::Read(i + topath("."+supported)) == "yes")
	    if (etst)
		return (SCR::Read(i + topath(".ENCAP")) == type);
	    else
		return true;
	else
	    return false;
    });
}

/**
 * Get providers from a group (country/other)
 * @param country we want providers from this country
 * @param type "all"|"isdn"|"rawip"|"syncppp"|"modem"|"dsl"
 * @param preselect preselect this provider
 * @return list of items for SelectionBox
 */
global define list GetProviders(string country, string type, string preselect) ``{
    list provs = [];

    y2debug("%1-%2-%3",country,type,preselect);
    /* Custom providers */
    if(country == "_custom") {
	foreach(`k, `v, providers, ``{
	    change(provs, k);
	});
    }
    /* Providers from given country */
    else {
	list dir = SCR::Dir(add(.providers.s, country));
	path base = add(.providers.v, country);
	provs = maplist(`i, dir, ``{
	    return add(base, i);
	});
    }

    y2debug("provs=%1",provs);
    /* Filter only desired providers */
    if(type != "" && type != "all" && type != nil)
	provs = FilterProviders(provs, type);

    y2debug("provs=%1",provs);
    /* Sort and create divider (line) */
    provs = SortProviders(provs);

    y2debug("provs=%1",provs);
    integer index = -1;
    return maplist(`i, provs, ``{
	index = index + 1;
	if(is(i, string))
	    return `item(`id(i), lookup(lookup(providers, i, $[]), "PROVIDER", i), 0 == index || preselect == i);
	else
	    if(."--" == i)
		return `item(`id(i), "----------------");
	    else
		return `item(`id(i), SCR::Read(i + .PROVIDER), 0 == index);
    });
}

/**
 * Sorts providers alphabeticly (non-case-sensitivly) and by priority.
 * In the first step, priority and name of each provider is obtained.
 * List of strings built from these values is created. Item lists are:
 * "<1-character-priority><34-characters-provider-name><provider-identifier>"
 * This list is sorted, result is correctly sorted, by priority and
 * alphabeticly. I did not use builtin sort with sort code because it
 * uses bubble sort -- it was bloody slow.
 * @param provs list of providers
 * @return sorted list of providers
 */
define list SortProviders(list provs) ``{
    list pre = sort(maplist(`i, add(provs, "--"), ``{
	if("--" == i)
	    return "9                                  .\"--\"";
	if(is(i, string))
	    return "x                                  " + i;
	else
	{
	    string tmp = SCR::Read(i + .PRIORITY);
	    if(nil == tmp)
		tmp = "-1";
	    integer p = 8 - tointeger(tmp);
	    if(p < 0 || p > 9)
		y2error("======= wrong priority, you must change the algorithm!!! %1 =======", tmp);
	    tmp = tolower(SCR::Read(i + .PROVIDER)) + "                                   ";
	    tmp = sformat("%1", p) + tmp;
	    return sformat("%1%2", substring(tmp, 0, 35), i);
	}
    }));
    if(".\"--\"" == substring(select(pre, 0, ""), 35))
	pre = remove(pre, 0);
    return maplist(`i, pre, ``{
	if("x" == substring(i, 0, 1))
	    return substring(i, 35);
	return topath(substring(i, 35));
    });
}

/**
 * Prepare for editation of currently selected provider.
 * Check/change its name (ShortName) and nice-name (Provider) to unused.
 * @param new true if create new provider, false if edit existing
 * /
global define void editProvider(boolean new) ``{

    /* generate unique ShortName * /
    integer suffix = 0;
    string name = lookup(provider, "ShortName", "");
    string gen = name;
    if(gen == "") {
	gen = "provider0";
	name = "provider";
    }

    list forbidden = mapkeys(providers);
    while(contains(forbidden, gen)) {
	suffix = suffix + 1;
	gen = sformat("%1%2", name, suffix);
    }
    provider = add(provider, "ShortName", gen);

    if(new) return;

    /* generate unique name * /
    name = lookup(provider, "PROVIDER", "");
    gen = name;

    suffix = 0;
    forbidden = maplist(`k, `v, providers, ``(v["PROVIDER"]:""));
    while(contains(forbidden, gen)) {
	suffix = suffix + 1;
	gen = sformat("%1 (%2)", name, suffix);
    }
    provider = add(provider, "PROVIDER", gen);

    // initialize provider with new values
    provider = union($[
	"MODIFYDNS" : "yes",
	"IDLETIME" : "300",
	"DEMAND" : "no",
	"DNS1" : "",
	"DNS2" : "",
    ], provider);

}
*/

/**
 * Read all provider keys from ini file to map.
 * Adds also key "ShortName" : "section_name";
 * @param provider which provider to get
 * @return provider map
 */
global define map ReadProvider(any provider) ``{
    y2debug("provider=%1",provider);
    if(provider != nil && is(provider, path)) {
	y2debug("path");
	string pr = sformat("%1", provider);
	integer pos = findlastof(pr, ".");
	if(pos != -1) {
	    pr = substring(pr, pos + 1);
	    pr = substring(pr, 0, size(pr));
	    if("\"" == substring(pr, 0, 1))
		pr = substring(pr, 1, size(pr) - 2);
	}
	list l = SCR::Dir(provider);
	return add(listmap(`i, l, ``{
	    return [ i, SCR::Read( add(provider, i)) ];
	}), "ShortName", pr);
    }
    y2debug("lookup: %1",lookup(providers, provider, $[]));
    return lookup(providers, provider, $[]);
}

/**
 * @param name provider name if Edit, empty if Add
 */
global define boolean AddEdit(any name, boolean clone) ``{
    operation = nil;

    y2warning("name=%1",name);
    y2warning("clone=%1",clone);

    /* edit existing */
    if(name != "") {

	provider = ReadProvider(name);
	y2debug("provider=%1",provider);

	string name = lookup(provider, "PROVIDER", "");
	string gen = name;

	if(clone) {
	    /* generate unique name */
	    integer suffix = 0;
	    list forbidden = maplist(`k, `v, providers, ``(v["PROVIDER"]:""));
	    while(contains(forbidden, gen)) {
		suffix = suffix + 1;
		gen = sformat("%1 (%2)", name, suffix);
	    }
	}

	provider = add(provider, "PROVIDER", gen);

	// initialize provider with new values
	provider = union($[
	    "MODIFYDNS" : "yes",
	    "IDLETIME" : "300",
	    "DEMAND" : "no",
	    "DNS1" : "",
	    "DNS2" : "",
	], provider);

    }

    /* add or clone existing */
    if(name == "" || clone) {

	if(name == "")
	    provider = $[];
	/* else is filled in the above if() */

	/* generate unique ShortName */
	integer suffix = 0;
	string name = lookup(provider, "ShortName", "");
	string gen = name;
	if(gen == "") {
	    gen = "provider0";
	    name = "provider";
	}

	list forbidden = mapkeys(providers);
	while(contains(forbidden, gen)) {
	    suffix = suffix + 1;
	    gen = sformat("%1%2", name, suffix);
	}
	provider = add(provider, "ShortName", gen);

    }

    /* name=="" -> Add */
    if(name == "")
	operation = `add;
    /* name!="" -> Edit */
    else
	operation = `edit;

    return true;
}

global define boolean Delete(string nam) ``{
    operation = nil;

    if(!haskey(providers, nam)) {
	y2error("Key not found: %1", nam);
	return false;
    }

    name = nam;
    operation = `delete;
    return true;
}

/**
 * Add currently edited provider to the map of custom providers.
 * Copy settings to Modem::something
 */
global define boolean Commit() ``{
    y2warning("Commit(%1)", operation);

    if(operation == `add || operation == `edit) {
	y2debug("providers=%1",providers);
	change(providers, provider["ShortName"]:"", provider);
	provShortName = lookup(provider, "ShortName", "");
	provLongName = lookup(provider, "PROVIDER", "");
	y2debug("providers=%1",providers);
    }
    else if(operation == `delete) {
	if(!haskey(providers, name)) {
	    y2error("Key not found: %1", name);
	    return false;
	}

	providers = remove(providers, name);
	change(DELETED, name);
    }
    else {
	providers = add(providers, lookup(provider, "ShortName", ""), provider);
	provShortName = lookup(provider, "ShortName", "");
	provLongName = lookup(provider, "PROVIDER", "");
	y2error("Unknown operation: %1", operation);
	return false;
    }

    modified = true;
    operation = nil;
    return true;
}

global define list Overview() ``{
    list overview = [];

    y2debug("providers=%1",providers);
    maplist(`name, `provmap, providers, ``{
	change(overview, `item(`id(name), name, provmap["PROVIDER"]:""));
    });
    y2debug("providers=%1",providers);
    return overview;
}

global define list Summary(boolean split) ``{

    string summary = "";
    if(size(providers) < 1)
	summary = Summary::AddHeader("", _("Nothing is configured."));
    else
	summary = Summary::AddHeader("", _("Already configured providers:"));

    list provs = [];
    maplist(`name, `provmap, providers, ``{
	string descr = sformat(_("Configured as %1"), name);
	change(provs, Summary::Device(provmap["PROVIDER"]:"", descr));
    });
    summary = Summary::DevicesList(provs);

    return [
	summary,
	[ `item(`id(`other), _("Modem provider"), true) ]
    ];
}

/* EOF */
}
