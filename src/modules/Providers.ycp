/**
 * File:	modules/Providers.ycp
 * Package:	Configuration of network
 * Summary:	Providers dialogs
 * Authors:	Dan Vesely <dan@suse.cz>
 *		Petr Blahos <pblahos@suse.cz>
 *		Michal Svec <msvec@suse.cz>
 *
 * $Id$
 *
 * Dialogs and functions for Providers.
 */

{

module "Providers";

textdomain "network";

import "DSL";
import "Modem";
import "ISDN";
import "Language";

/**
 * Modem we are currently working with.
 * Members for dialup - phone provider:
 * "DialMessage1" :
 * "DialMessage2" :
 * "Provider" : nice name of provider
 * "ShortName" : short name of provider (name of the section in *.conf)
 * "Username" :
 * "Password" :
 * "Ask Password" : "no" or "yes"
 * "Phone" : the most important - phone number
 * "DNS1" : first dns
 * "DNS2" : second dns
 *
 * Members for isdn provider:
 * "DialMessage1" :
 * "DialMessage2" :
 * "Provider" : nice name of provider
 * "ShortName" : short name of provider (name of the section in *.conf)
 * "Username" :
 * "Password" :
 * "Phone" : the most important - phone number
 * "I4L_ENCAP" : encapsulation but who knows what it means
 */
global map provider = $[];

/**
 * provider settings
 */
global string provShortName = "";
global string provLongName = "";

/**
 * Dirty bit
 */
boolean dirty = false;

/**
 * Custom providers.
 */
map providers = $[];

/**
 * Countries list
 */
list countries = [];

/**
 * Countries list
 */
string language = "";

/**
 * Export data
 * @return dumped settings (later acceptable by Import())
 */
global define map Export() ``{
    return providers;
}

/**
 * Import data
 * @param in settings to be imported
 * @return true on success
 */
global define map Import(map in) ``{
    providers = in;
    provider = $[];
    dirty = true;
}

/**
 * Were the providers changed?
 * @return true if modified
 */
global define boolean Modified() ``{
    return dirty;
}

/**
 * Most probably it means to check if section name in .conf is unique
 * @param name section name
 * @return true if OK
 */
global define boolean IsSectionUnique (string name) ``{
    list forbidden = maplist (`k, `v, providers, ``( k ));
    return !contains (forbidden, name);
}

/**
 * Most probably it means to check if provider name in .conf is unique
 * @param name provider name
 * @return true if OK
 */
global define boolean IsProviderUnique (string name) ``{
    list forbidden = maplist (`k, `v, providers, ``( lookup (v, "PROVIDER", "")));
    return !contains (forbidden, name);
}

/**
 * Prepare for editation of currently selected provider.
 * Check/change its name (ShortName) and nice-name (Provider) to unused.
 * @param prov_id provider to edit
 */
global define void editProvider (any prov_id) ``{
    if (is (prov_id, string)) //User chose provider from "Other" -- edit it.
	return ;
    integer suffix = 0;
    string name = lookup (provider, "ShortName", "");
    string gen = name;
    list forbidden = maplist (`k, `v, providers, ``( k ));
    while (contains (forbidden, gen))
    {
	suffix = suffix + 1;
	gen = sformat ("%1%2", name, suffix);
    }
    provider = add (provider, "ShortName", gen);

    name = lookup (provider, "PROVIDER", "");
    gen = name;
    suffix = 0;
    forbidden = maplist (`k, `v, providers, ``( lookup (v, "PROVIDER", "")));
    while (contains (forbidden, gen))
    {
	suffix = suffix + 1;
	gen = sformat ("%1 (%2)", name, suffix);
    }
    provider = add (provider, "PROVIDER", gen);
    // initialize provider with new values
    provider = union ($[
	    "AUTODNS" : "yes",
	    "IDLETIME" : "300",
	    "DEMAND" : "no",
	    "DNS1" : "",
	    "DNS2" : "", ],
	    provider);
}

/**
 * Add currently edited provider to the map of custom providers.
 * Copy settings to Modem::something
 */
global define void Commit() ``{
    providers = add(providers, lookup(provider, "ShortName", ""), provider);
    provShortName = lookup (provider, "ShortName", "");
    provLongName = lookup (provider, "PROVIDER", "");
    dirty = true;
}

/**
 * Read providers data (custom only) and country mappings
 * @return true if success
 */
global define boolean Read() ``{

    boolean ret = true;

    /* read custom providers */
    providers = $[];
    list dir = SCR::Dir(.sysconfig.network.providers.s);
    foreach(`shortname, dir, ``{
	path provider = add(.sysconfig.network.providers.v, shortname);
	map p = listmap(`i, SCR::Dir(provider), ``{
	    return [ i, SCR::Read(add(provider, i)) ];
	});
	change(p, "ShortName", shortname);
	change(providers, shortname, p);
    });

    /* read countries */
    map country_names = SCR::Read(.target.yast2, "country.ycp");
    if(country_names == nil) {
	//Report:Error(_("Country database not found"));
	y2error("Country database not found");
	country_names = $[];
	ret = false;
    }
    textdomain "country_db";
    country_names = eval(country_names);
    textdomain "network";

    /* local language heuristics */
    language = Language::language;
    y2debug("language=%1",language);
    if(language == nil || language == "")
	/* FIXME make default_language global */
	language = Language::default_language;
    else
	language = "";
    if(language != nil && language != "")
	if(find(language, "@") != -1)
	    language = select(splitstring(language, "@"), 0, "");
    if(language != nil && language != "")
	if(find(language, "_") != -1)
	    language = select(splitstring(language, "_"), 1, "");
    y2debug("language=%1",language);

    /* initialize the countries selection box */
    countries = [];
    integer index = -1;
    countries = SCR::Dir(.providers.s);
    y2debug("countries=%1",countries);
    if(!contains(countries, language)) language = "CZ";
    countries = maplist(`i, countries, ``{
	index = index + 1;
	return `item(`id(i), country_names[i]:i, i == language);
    });
    y2debug("countries=%1", countries);

    return ret;
}

/**
 * Write custom providers data
 * @return true if sucess
 */
global define boolean Write() ``{

    boolean ret = true;

    /* write custom providers */
    foreach(`key, `value, providers, ``{
	string sname = lookup(value, "ShortName", "other");
	sname = filterchars(sname, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-.");
	path base = add(.sysconfig.network.providers.v, sname);
	foreach(`k, `v, completeProvider(value), ``{
	    // adjust some values
	    if("ASKPASSWORD" == k || "STUPIDMODE" == k || "COMPUSERVE" == k || "ISDNSUPPORTED" == k || "DSLSUPPORTED" == k || "MODEMSUPPORTED" == k)
	    {
		if("0" == v)		v = "no";
		else if("1" == v)	v = "yes";
		else if("no" != v && "yes" !=v)
		    v = (-1 != find(v, "no") ? "no" : "yes");
	    }
	    if("ShortName" != k)
		SCR::Write(add(base, k), v);
	});
    });
    SCR::Write(.sysconfig.network.providers, nil);

    /* change the rights (provider can contain password #13353  */
    SCR::Execute(.target.bash, "/bin/chown -R root:root /etc/sysconfig/network/providers");
    SCR::Execute(.target.bash, "/bin/chmod -R 0600 /etc/sysconfig/network/providers");

    return ret;
}

/**
 * Ensure all neccesary items are present.
 * @param prov provider map
 * @return new provider map with all entries
 */
define map completeProvider(map prov) ``{
    if(!haskey(prov, "MODEMSUPPORTED"))
	prov = add(prov, "MODEMSUPPORTED", "yes");
    if(!haskey(prov, "ISDNSUPPORTED"))
	prov = add(prov, "ISDNSUPPORTED", "no");
    if(!haskey(prov, "DSLSUPPORTED"))
	prov = add(prov, "DSLSUPPORTED", "no");
    return prov;
}

/**
 * Get list of countries
 * @return list for SelectionBox
 */
global define list GetCountries() ``{
    return countries;
}

/**
 * Filter providers based on the type
 * @param provs list of providers
 * @param type desired type "modem"|"isdn"|"dsl"
 * @return list of type capable providers
 */
define list FilterProviders(list provs, string type) ``{
    string supported = toupper(type) + "SUPPORTED";
    y2debug("supported=%1",supported);

    return filter(`i, provs, ``{
	y2debug("i=%1", i);
	if(is(i, string))
	    return lookup(lookup(providers, i, $[]), supported, "no") == "yes";
	else if(SCR::Read(i + topath("."+supported)) == "yes")
	    return true;
	return false;
    });
}

/**
 * Get providers from a group (country/other)
 * @param country we want providers from this country
 * @param type "all"|"isdn"|"modem"|"dsl"
 * @param preselect preselect this provider
 * @return list of items for SelectionBox
 */
global define list GetProviders(string country, string type, string preselect) ``{
    list provs = [];

    /* Custom providers */
    if(country == "_custom") {
	foreach(`k, `v, providers, ``{
	    change(provs, k);
	});
    }
    /* Providers from given country */
    else {
	list dir = SCR::Dir(add(.providers.s, country));
	path base = add(.providers.v, country);
	provs = maplist(`i, dir, ``{
	    return add(base, i);
	});
    }

    /* Filter only desired providers */
    if(type != "" && type != "all" && type != nil)
	provs = FilterProviders(provs, type);

    /* Sort and create divider (line) */
    provs = SortProviders(provs);

    integer index = -1;
    return maplist(`i, provs, ``{
	index = index + 1;
	if(is(i, string))
	    return `item(`id(i), lookup(lookup(providers, i, $[]), "PROVIDER", i), 0 == index || preselect == i);
	else
	    if(."--" == i)
		return `item(`id(i), "----------------");
	    else
		return `item(`id(i), SCR::Read(i + .PROVIDER), 0 == index);
    });
}

/**
 * Read all provider keys from ini file to map.
 * Adds also key "ShortName" : "section_name";
 * @param provider which provider to get
 * @return provider map
 */
global define map GetProvider(any provider) ``{
    y2debug("provider=%1",provider);
    if(is(provider, path)) {
	string pr = sformat("%1", provider);
	integer pos = findlastof(pr, ".");
	if(pos != -1) {
	    pr = substring(pr, pos + 1);
	    pr = substring(pr, 0, size(pr));
	    if("\"" == substring(pr, 0, 1))
		pr = substring(pr, 1, size(pr) - 2);
	}
	list l = SCR::Dir(provider);
	return add(listmap(`i, l, ``{
	    return [ i, SCR::Read( add(provider, i)) ];
	}), "ShortName", pr);
    }
    return lookup(providers, provider, $[]);
}

/**
 * Sorts providers alphabeticly (non-case-sensitivly) and by priority.
 * In the first step, priority and name of each provider is obtained.
 * List of strings built from these values is created. Item lists are:
 * "<1-character-priority><34-characters-provider-name><provider-identifier>"
 * This list is sorted, result is correctly sorted, by priority and
 * alphabeticly. I did not use builtin sort with sort code because it
 * uses bubble sort -- it was bloody slow.
 * @param provs list of providers
 * @return sorted list of providers
 */
define list SortProviders(list provs) ``{
    list pre = sort (maplist (`i, add (provs, "--"), ``{
	if ("--" == i)
	    return "9                                  .\"--\"";
	if (is (i, string))
	    return "x                                  " + i;
	else
	{
	    string tmp = SCR::Read (i + .PRIORITY);
	    if (nil == tmp)
		tmp = "-1";
	    integer p = 8 - tointeger (tmp);
	    if (p < 0 || p > 9)
		y2error ("======= wrong priority, you must change the algorithm!!! %1 =======", tmp);
	    tmp = tolower (SCR::Read (i + .PROVIDER)) + "                                   ";
	    tmp = sformat ("%1", p) + tmp;
	    return sformat ("%1%2", substring (tmp, 0, 35), i);
	}
    }));
    if (".\"--\"" == substring (select (pre, 0, ""), 35))
	pre = remove (pre, 0);
    return maplist (`i, pre, ``{
	if ("x" == substring (i, 0, 1))
	    return substring (i, 35);
	return topath (substring (i, 35));
    });
}

/* EOF */
}
