/**
 * File:	modules/DNS.ycp
 * Package:	Network configuration
 * Summary:	Hostname and DNS data
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 */

{

module "DNS";
textdomain "network";

import "Detection";
import "Host";
import "Hostname";
import "NetworkConfig";
import "NetworkDevices";

/* NI: required wrt functions in routines.ycp */
block<boolean> AbortFunction = nil;
define boolean Modified() { return true; }

include "network/routines.ycp";
include "network/runtime.ycp";

global string hostname = "";
global string domain = "";
global list<string> nameservers = [];
global list<string> searchlist = [];
global string resolv_conf_process = "";
global boolean resolv_conf_force = false;

string oldhostname = "";
global list<string> oldhostnames = [];

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 * "routes" file location
 */
string resolv_conf = "/etc/resolv.conf";

/**
 * Reads current DNS and hostname settings
 * @return true if success
 */
global define boolean Read() {

    NetworkConfig::Read();

    /* install.inf from linuxrc */
    map install_inf = $[];
    if(SCR::Read(.target.size, "/etc/install.inf") > 0)
	install_inf = (map) SCR::Read(.etc.install_inf);

    /* check for externally modified resolv.conf */
    if(SCR::Execute(.target.bash, "/sbin/modify_resolvconf check -q < /dev/null") != 0)
	resolv_conf_process = (string) SCR::Read(.etc.resolv_conf.process);

    /* only read /etc/resolv.conf if present */
    if(SCR::Read(.target.size, resolv_conf) > 0) {

	/* name servers */
	list<string> resolvlist = (list<string>) SCR::Read(.etc.resolv_conf.nameserver);
	if(resolvlist == nil) {
	    if(size(install_inf["nameserver"]:"") > 0)
		nameservers = add(nameservers, install_inf["nameserver"]:"");
	}
	else
	    nameservers = resolvlist;

	/* search list */
	resolvlist = (list<string>) SCR::Read(.etc.resolv_conf.search);
	if(resolvlist != nil) searchlist = resolvlist;
	if(size(searchlist) < 1) {
	    string dom = (string) SCR::Read(.etc.resolv_conf.domain);
	    if(dom != nil && dom != "") searchlist = [ dom ];
	}
    }
    else {
	/* FIXME: propose DNS from Detection */
    }

    /* host name and domain */
    string fqhostname = "";
    if(SCR::Read(.target.size, "/etc/HOSTNAME") > 0) {
	fqhostname = (string) SCR::Read(.target.string, "/etc/HOSTNAME");
	fqhostname = substring(fqhostname, 0, findfirstof(fqhostname, "\n"));
	oldhostname = fqhostname;
    }

    if(fqhostname != "") {
	list split = Hostname::SplitFQ(fqhostname);
	hostname = split[0]:"";
	domain = split[1]:"";
    }
    else {
	/* default hostname and domain (if not in /etc/install.inf) */
	hostname = install_inf["machinename"]:(Detection::result["HOSTNAME"]:"linux");
	domain = install_inf["domain"]:(Detection::result["DOMAIN"]:"local");
    }

    return true;
}

/**
 * Write new DNS and hostname settings
 * @return true if success
 */
global define boolean Write() {

    NetworkConfig::Write();

    y2milestone("Writing configuration");
    if(!modified) {
	y2milestone("No changes to DNS -> nothing to write");
	return true;
    }

    /* build FQ hostname */
    string fqhostname = Hostname::MergeFQ(hostname, domain);

    /* Allow to set hostname even if it's modified by DHCP (#bug)
    if(NetworkConfig::DHCP["DHCLIENT_SET_HOSTNAME"]:false != true) { */

	/* remember the X authorization key */
	string xauth_key = (string) SCR::Read(.xauth.key);

	/* change the hostname */
	SCR::Execute(.target.bash, "/bin/hostname " + hostname);

	/* write hostname */
	SCR::Write(.target.string, "/etc/HOSTNAME", fqhostname + "\n");

	/* Update /etc/hosts */
	list<string> devs = NetworkDevices::LocateNOT("IPADDR", "");
	list<string> ips = maplist(string dev, devs, {
	    return NetworkDevices::GetValue(dev, "IPADDR");
	});
	Host::Update(fqhostname, oldhostname, ips);

	/* Finish him */
	RunSuSEconfig();

	/* update X authorization */
	SCR::Write(.xauth.key, xauth_key);

    if(SCR::Read(.target.size, resolv_conf) < 0)
	SCR::Write(.target.string, resolv_conf, "");

    /* either no process or force update */
    if(resolv_conf_process == "" || resolv_conf_force == true) {

	/* update /etc/resolv.conf */
	SCR::Write(.etc.resolv_conf.search, searchlist);
	SCR::Write(.etc.resolv_conf.nameserver, nameservers);
	/* update domain in /etc/resolv.conf */
	if(size(searchlist) > 0)
	    SCR::Write(.etc.resolv_conf.domain, "");
	else
	    SCR::Write(.etc.resolv_conf.domain, domain);

	/* write only an original header */
	if(resolv_conf_force == true &&
		(NetworkConfig::DHCP["DHCLIENT_MODIFY_RESOLV_CONF"]:false == true)) {
	    SCR::Write(.etc.resolv_conf.write_header, true);
	}

	/* flush the cache */
	SCR::Write(.etc.resolv_conf, nil);
	SCR::Execute(.target.bash, "/bin/chmod a+r /etc/resolv.conf");

    }

    modified = false;
    return true;
}

/**
 * Get all the DNS configuration from a map.
 * When called by dns_auto (preparing autoinstallation data)
 * the map may be empty.
 * @param settings autoinstallation settings
 * @return true if success
 */
global define boolean Import(map settings) {
    if(size(settings) == 0)
	return false;

    hostname = settings["hostname"]:"";
    domain = settings["domain"]:"";
    nameservers = (list<string>) eval(settings["nameservers"]:[]);
    searchlist = (list<string>) eval(settings["searchlist"]:[]);
    modified = true;
    return true;
}

/**
 * Dump the DNS settings to a map, for autoinstallation use.
 * @return autoinstallation settings
 */
global define map Export() {
    return $[
	"hostname"	: hostname,
	"domain"	: domain,
	"nameservers"	: eval(nameservers),
	"searchlist"	: eval(searchlist),
    ];
}

/**
 * Create DNS text summary
 * @return summary text
 */
global define string Summary() {

    string summary = "<p>";

    if(NetworkConfig::DHCP["DHCLIENT_SET_HOSTNAME"]:false == true)
	/* Summary text */
	summary = summary + _("Host Name: set by DHCP");
    else
	/* Summary text */
	summary = summary + sformat(_("Host Name: %1"), Hostname::MergeFQ(hostname, domain));

    summary = summary + "<p>";

    if(NetworkConfig::DHCP["DHCLIENT_MODIFY_RESOLV_CONF"]:false == true) {
	/* Summary text */
	summary = summary + _("Name Servers: set by DHCP") + "<br>";
	/* Summary text */
	summary = summary + _("Search List: set by DHCP");
    }
    else {
	/* Summary text */
	summary = summary + sformat(_("Name Servers: %1"), nameservers) + "<p>";
	/* Summary text */
	summary = summary + sformat(_("Search List: %1"), searchlist);
    }

    return summary;
}

/* EOF */
}
