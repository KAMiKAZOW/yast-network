/**
 * File:
 *   modules/Lan.ycp
 *
 * Package:
 *   Configuration of network
 *
 * Summary:
 *   Data for configuration of network card, input and output functions.
 *
 * Authors:
 *   Michal Svec <msvec@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of network cards.
 * Input and output routines.
 *
 */

{

module "Lan";
textdomain "network";

import "DNS";
import "Routing";
import "Progress";
import "Summary";

include "network/config.ycp";
include "network/hardware.ycp";
include "network/routines.ycp";
include "network/runtime.ycp";
include "network/ip.ycp";

/*-------------*/
/* GLOBAL DATA */

/* kernel options */
global string name = "";
global string modul = "";
global string options = "";
global string unique = "";
global string type = "";

global boolean pcmcia = false;

/* address options */
global string bootproto = "static";
global string ipaddr = "";
global string netmask = "";
global integer device = -1;

/**
 * Abort function
 * return boolean return true if abort
 */
global block AbortFunction = nil;

/*--------------*/
/* PRIVATE DATA */

/**
 * Config information
 */
map CONFIG = $[];

/**
 * Hardware information
 * [
 *     "name"	: "Digital DecCHIP 1234",
 *     "unique"	: "uihd98723hodi2hgday8",
 *     "modul"	: "tulip",
 *     "options" : ""
 * ]
 */
list HARDWARE = [];

/**
 * Deleted devices
 */
list DELETED = [];

/**
 * Data was modified?
 */
boolean modified = false;

/**
 * Which operation is pending?
 */
symbol operation = nil;

/*------------------*/
/* GLOBAL FUNCTIONS */

/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() ``{
    y2debug("modified=%1",modified);
    return modified;
};

/**
 * Read all network settings from the SCR
 * @return true on success
 */
global define boolean Read() ``{

    string caption = _("Initializing network configuration");
    integer steps = 6;

    /* FIXME */
    integer sl = 0; //1000;
    sleep(sl);

    Progress::New(caption, " ", steps, [
	_("Detect devices"),
	_("Read current configuration"),
	_("Read routing configuration"),
	_("Read hostname and DNS configuration"),
	_("Read installation information"),
	_("Detect current status"),
    ], [], "");

    if(Abort()) return false;
    ProgressNextStage(_("Detecting network cards"));
    ReadHardware();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Reading current configuration"));
    ReadConfig("eth|tr");
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Reading routing configuration"));
    Routing::Read();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Reading hostname and DNS configuration"));
    DNS::Read();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Reading installation information"));
    //ReadInstallInf();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Detecting current status"));
    ReadStatus();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Update the SCR according to network settings
 * @return true on success
 */
global define boolean Write() ``{

    string caption = _("Saving network configuration");
    integer steps = 7;

    /* FIXME */
    integer sl = 0; //1000;
    sleep(sl);

    Progress::New(caption, " ", steps, [
	_("Stop network"),
	_("Write configuration"),
	_("Write drivers information"),
	_("Write routing configuration"),
	_("Write hostname and DNS configuration"),
	_("Run SuSEconfig"),
	_("Start network"),
    ], [], "");

    if(Abort()) return false;
    ProgressNextStage(_("Stopping network"));
    StopNetwork();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Writing configuration"));
    WriteConfig();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Writing /etc/modules.conf"));
    WriteModulesConf();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Writing routing configuration"));
    Routing::Write();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Writing hostname and DNS configuration"));
    DNS::Write();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Running SuSEconfig"));
    RunSuSEconfig();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Starting network"));
    StartNetwork();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Get all network settings from the first parameter
 * (for use by autoinstallation)
 * @param settings a map of settings to be imported.
 * @return true on success
 */
global define boolean Import(map settings) ``{
    CONFIG = settings["config"]:$[];
    DNS::Import(settings["dns"]:$[]);
    Routing::Import(settings["routing"]:$[]);
}

/**
 * Dump the network settings to a single map
 * (for use by autoinstallation)
 * @return dumped settings (later acceptable by Import())
 */
global define map Export() ``{
    return $[
	"config"  : CONFIG,
	"dns"     : DNS::Export(),
	"routing" : Routing::Export()
    ];
}

/**
 * Build a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global define list Summary() ``{

    list configured = [];
    list unconfigured = [];

    maplist(`d, HARDWARE, ``{
	string hwname = lookup(d, "name", _("Unknown network card"));
	string ty = lookup(d, "type", "eth");
	string un = lookup(d, "unique", nil);
	string status = IsConfigured(ty, un);
	y2debug("status(%1)=%2",status,d);
	if(status != "")
	    change(configured, Summary::Device(hwname, status));
	else
	    change(unconfigured, d);
    });

    list allhw = maplist(`d, HARDWARE, ``(lookup(d, "unique", nil)));
    maplist(`s, OtherConfigured(allhw), ``{
	change(configured, Summary::Device(_("Unknown network card"), s));
    });

    string summary = "";
    if(size(configured) > 0)
	summary = Summary::AddHeader("", _("Already configured network cards:")) +
	    Summary::DevicesList(configured);
    else
	summary = Summary::AddHeader("", _("No configured network card."));

    integer selected = lookup(select(unconfigured, 0, $[]), "num", 0);
    list devs = hwlist2items(unconfigured, selected);
    if(size(devs)==0)
	change(devs, `item(`id(`other), _("Other (not detected)"), true));
    else
	change(devs, `item(`id(`other), _("Other (not detected)")));

    return [ devs, summary ];
}

/**
 */
global define list Overview() ``{
    return merge(CreateOverview("eth"), CreateOverview("tr"));
}

/*-------------------*/
/* PRIVATE FUNCTIONS */

/**
 * Abort function
 * @return blah blah lahjk
 */
define boolean Abort() ``{
    if(AbortFunction != nil)
	return eval(AbortFunction) == true;
    return false;
}

/**
 * Return 10 free devices
 * @param type device type
 * @return list of 10 free devices
 */
global define list FreeDevices(string type) ``{
    y2debug("CONFIG=%1",CONFIG);
    return GetFreeDevices(type, 10);
}

/**
 * Check if the given device is configured and return
 * the corresponding device
 * @param type device type
 * @return device if configured, empty string if not
 */
global define string Configured(string type, string unique) ``{
    return IsConfigured(type, unique);
}

/**
 * Select the given hardware item or clean up structures
 * @param which item to be chosen
 */
global define void SelectHW(integer which) ``{
    map sel = $[];

    if(which != nil)
	sel = select(HARDWARE, which, $[]);

    if(which > size(HARDWARE) || which < 0)
	y2error("Item not found in HARDWARE: %1 (%2)", which, size(HARDWARE));

    name = lookup(sel, "name", "");
    unique = lookup(sel, "unique", "");
    modul = lookup(sel, "module", "");
    options = lookup(sel, "options", "");
    unique = lookup(sel, "unique", "");
    type = lookup(sel, "type", "eth");
    device = select(GetFreeDevices(type,1), 0, -1);
}

/**
 * @return true if success
 */
global define boolean Add() ``{

    /* kernel options */
    name = "";
    modul = "";
    options = "";
    unique = "";
    type = "eth";

    pcmcia = false;

    /* address options */
    bootproto = "static";
    ipaddr = "";
    netmask = "";
    device = select(GetFreeDevices(type,1), 0, -1);

    operation = `add;
    return true;
}

/**
 * @return true if success
 */
global define boolean Edit(string dev) ``{
    operation = nil;
    string typ = device_type(dev);
    integer num = device_num(dev);
    string n = sformat("%1",num);

    map typemap = lookup(CONFIG, typ, $[]);
    if(!haskey(typemap, n)) {
	y2error("Key not found: %1", dev);
	return false;
    }
    map devmap = lookup(typemap, n, $[]);

    /* address options */
    bootproto = lookup(devmap, "BOOTPROTO", "static");
    ipaddr = lookup(devmap, "IPADDR", "");
    netmask = lookup(devmap, "NETMASK", "");
    unique = lookup(devmap, "UNIQUE", "");
    device = num;
    type = typ;

    operation = `edit;
    return true;
}

/**
 * @return true if success
 */
global define boolean Delete(string dev) ``{
    operation = nil;
    string typ = device_type(dev);
    integer num = device_num(dev);

    map typemap = lookup(CONFIG, typ, $[]);
    if(!haskey(typemap, sformat("%1",num))) {
	y2error("Key not found: %1", dev);
	return false;
    }

    type = typ;
    device = num;
    operation = `delete;
    return true;
}

/**
 * @return true if success
 */
global define boolean Commit() ``{
    y2debug("Commit(%1)",operation);
    if(operation == `add || operation == `edit) {
	map newdev = $[
	    "BOOTMODE"	: "onboot",
	    "BOOTPROTO"	: bootproto,
	    "UNIQUE"	: unique,
	];
	//if(bootproto == "static") {
	if(ipaddr != "") {
	    change(newdev, "IPADDR", ipaddr);
	    change(newdev, "NETMASK", netmask);
	    change(newdev, "BROADCAST", compute_broadcast(ipaddr, netmask));
	    change(newdev, "NETWORK", compute_network(ipaddr, netmask));
	}
	change(newdev, "module", modul);
	change(newdev, "options", options);
	if(operation == `add)
	    ConfigAdd(type, device, newdev,true);
	else
	    ConfigAdd(type, device, newdev,false);
    }
    else if(operation == `delete) {
	ConfigDelete(type, device);
	change(DELETED, type+device);
    }
    else {
	y2error("Unknown operation: %1", operation);
	return false;
    }

    modified = true;
    operation = nil;
    return true;
}

/* EOF */
}
