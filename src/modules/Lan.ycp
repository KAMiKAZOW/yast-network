/**
 * File:	modules/Lan.ycp
 * Package:	Network configuration
 * Summary:	Network card data
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of network cards.
 * Input and output routines.
 */

{

module "Lan";
textdomain "network";

import "Arch";
import "DNS";
import "Detection";
import "Routing";
import "Firewall";
import "Progress";
import "Summary";

include "network/dns.ycp";
include "network/complex.ycp";
include "network/devices.ycp";
include "network/hardware.ycp";
include "network/install.ycp";
include "network/ip.ycp";
include "network/modules.ycp";
include "network/routines.ycp";
include "network/runtime.ycp";

/*-------------*/
/* GLOBAL DATA */

/**
 * Current module information
 */
global map Module = $[];

global string name = "";
global string unique = "";

global string type = "";
global string device = "";

/**
 * Hotplug type ("" if not hot pluggable)
 */
global string hotplug = "";

/* address options */
global string bootproto = "static";
global string ipaddr = "";
global string remoteip = "";
global string netmask = "";
global string mtu = "";

/* wireless options */
// FIXME: wlan global boolean wireless = false;
global string wl_mode = "";
global string wl_essid = "";
global string wl_nwid = "";
global string wl_key = "";
global string wl_nick = "";

/* s390 options */
global string read_channel = "";
global string write_channel = "";
global string data_channel = "";
global string portname = "";

/* global options */
global integer wait_for_interfaces = nil;

/* propose options */
global boolean proposal_valid = false;
global boolean write_only = false;

global boolean dhclient_broadcast = false;
global string dhclient_id = "";

/**
 * Abort function
 * return boolean return true if abort
 */
global block AbortFunction = nil;

/*--------------*/
/* PRIVATE DATA */

/**
 * Hardware information
 * @see ReadHardware
 */
list Hardware = [];

/**
 * Devices information
 * @see ReadDevices
 */
map Devices = $[];

/**
 * Deleted devices
 */
list DeletedDevices = [];

/**
 * Modules information
 * @see ReadModules
 */
map Modules = $[];

/**
 * Deleted modules
 */
list DeletedModules = [];

/**
 * /etc/install.inf data
 */
map InstallInf = $[];

/**
 * Data was modified?
 */
boolean modified = false;

/**
 * Which operation is pending?
 */
global symbol operation = nil;
// FIXME: used in lan/address.ycp (#17346) -> "global"

/*------------------*/
/* GLOBAL FUNCTIONS */

/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() ``{
    y2debug("modified=%1",modified);
    return modified;
};

/**
 * Read all network settings from the SCR
 * @return true on success
 */
global define boolean Read() ``{

    /* Read dialog caption */
    string caption = _("Initializing network configuration");
    integer steps = 9;

    integer sl = 0; /* 1000; /* TESTING */
    sleep(sl);

    Progress::New(caption, " ", steps, [
	/* Progress stage 1/9 */
	_("Detect network devices"),
	/* Progress stage 2/9 */
	_("Read /etc/modules.conf"),
	/* Progress stage 3/9 */
	_("Read current configuration"),
	/* Progress stage 4/9 */
	_("Read DHCP configuration"),
	/* Progress stage 5/9 */
	_("Read routing configuration"),
	/* Progress stage 6/9 */
	_("Read host name and DNS configuration"),
	/* Progress stage 7/9 */
	_("Read installation information"),
	/* Progress stage 8/9 */
	_("Read firewall settings"),
	/* Progress stage 9/9 */
	_("Detect current status"),
    ], [], "");

    if(Abort()) return false;
    /* Progress step 1/9 */
    ProgressNextStage(_("Detecting network devices..."));
    // if(!Arch::s390) /* FIXME: Temporary hack until the detection is functional */
    ReadHardware("netcard");
    /* ReadHardware(""); /* TESTING */
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 2/9 */
    ProgressNextStage(_("Reading /etc/modules.conf..."));
    ReadModules(NetworkCardRegex);
    /* ReadModules(""); /* TESTING */
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 3/9 */
    ProgressNextStage(_("Reading current configuration..."));
    ReadDevices(NetworkDeviceRegex);
    CleanHotplugSymlink();
    /* ReadDevices(""); /* TESTING */
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 4/9 */
    ProgressNextStage(_("Reading DHCP configuration..."));
    /* Read network config data */
    string wait = SCR::Read(.sysconfig.network.config.WAIT_FOR_INTERFACES);
    if(wait != "" && wait != nil) wait_for_interfaces = tointeger(wait);
    /* Read dhcp config data */
    dhclient_id = SCR::Read(.sysconfig.dhcp.DHCLIENT_CLIENT_ID);
    if(dhclient_id == nil) dhclient_id = "";
    wait = SCR::Read(.sysconfig.dhcp.DHCLIENT_ADDITIONAL_OPTIONS);
    if(wait != nil && issubstring(wait, "-B")) dhclient_broadcast = true;
    y2milestone("id=%1", dhclient_id);
    y2milestone("bc=%1", dhclient_broadcast);
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 5/9 */
    ProgressNextStage(_("Reading routing configuration..."));
    Routing::Read();
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 6/9 */
    ProgressNextStage(_("Reading host name and DNS configuration..."));
    DNS::Read();
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 7/9 */
    ProgressNextStage(_("Reading installation information..."));
    ReadInstallInf();
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 8/9 */
    ProgressNextStage(_("Reading firewall settings..."));
    Firewall::Read();
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 9/9 */
    ProgressNextStage(_("Detecting current status..."));
    ReadStatus();
    sleep(sl);

    if(Abort()) return false;
    /* Final progress step */
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}

/**
 * Only write configuration without starting any init scripts and SuSEconfig
 * @return true on success
 */
global define boolean WriteOnly()``{
       write_only = true;
       return Write();
}

/**
 * Update the SCR according to network settings
 * @return true on success
 */
global define boolean Write() ``{

    if(!modified) return true;
    y2milestone("Writing configuration");

    /* Write dialog caption */
    string caption = _("Saving network configuration");
    integer steps = 10;

    integer sl = 0; /* 1000; /* TESTING */
    sleep(sl);

    Progress::New(caption, " ", steps, [
	/* Progress stage 1/10 */
	_("Deactivate local network services"),
	/* Progress stage 2/10 */
	_("Write drivers information"),
	/* Progress stage 3/10 */
	_("Write configuration"),
	/* Progress stage 4/10 */
	_("Write DHCP configuration"),
	/* Progress stage 5/10 */
	_("Write routing configuration"),
	/* Progress stage 6/10 */
	_("Write host name and DNS configuration"),
	/* Progress stage 7/10 */
	_("Set up network services"),
	/* Progress stage 8/10 */
	_("Write firewall settings"),
	/* Progress stage 9/10 */
	_("Activate network services"),
	/* Progress stage 10/10 */
	_("Run SuSEconfig"),
    ], [], "");

    /* Stop the detection */
    if(!write_only && Detection::running) Detection::Stop();

    if(Abort()) return false;
    /* Progress step 1/10 */
    ProgressNextStage(_("Deactivating local network services..."));
    if(!write_only) StopNetwork();
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 2/10 */
    ProgressNextStage(_("Writing /etc/modules.conf..."));
    WriteModules();
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 3/10 */
    ProgressNextStage(_("Writing configuration..."));
    WriteDevices();
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 4/10 */
    ProgressNextStage(_("Writing DHCP configuration..."));
    /* Write network config data */
    if(wait_for_interfaces != nil) {
	SCR::Write(.sysconfig.network.config.WAIT_FOR_INTERFACES, sformat("%1",wait_for_interfaces));
	SCR::Write(.sysoncfig.network.config, nil);
    }
    /*  Write dhcp config data */
    if(dhclient_id != nil)
	SCR::Write(.sysconfig.dhcp.DHCLIENT_CLIENT_ID, dhclient_id);
    string options = SCR::Read(.sysconfig.dhcp.DHCLIENT_ADDITIONAL_OPTIONS);
    if(options != nil) {
	if(dhclient_broadcast && !issubstring(options, "-B")) {
	    SCR::Write(.sysconfig.dhcp.DHCLIENT_ADDITIONAL_OPTIONS, options + " -B");
	}
	else if(!dhclient_broadcast && issubstring(options, "-B")) {
	    SCR::Write(.sysconfig.dhcp.DHCLIENT_ADDITIONAL_OPTIONS, regexpsub(options, "(.*)-B(.*)", "\\1\\2"));
	}
    }
    SCR::Write(.sysoncfig.dhcp, nil);
    y2milestone("id=%1", dhclient_id);
    y2milestone("bc=%1 (%2)", dhclient_broadcast, options);
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 5/10 */
    ProgressNextStage(_("Writing routing configuration..."));
    Routing::Write();
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 6/10 */
    ProgressNextStage(_("Writing host name and DNS configuration..."));
    DNS::Write();
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 7/10 */
    ProgressNextStage(_("Setting up network services..."));
    EnableNetwork();
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 8/10 */
    ProgressNextStage(_("Writing firewall settings..."));
    Firewall::Write();
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 9/10 */
    ProgressNextStage(_("Activating network services..."));
    if(!write_only) StartNetwork();
    if(!write_only) RestartService("pcmcia");
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 10/10 */
    ProgressNextStage(_("Running SuSEconfig..."));
    if(!write_only) RunSuSEconfig();
    sleep(sl);

    if(Abort()) return false;
    /* Final progress step */
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Import data
 * @param settings settings to be imported
 * @return true on success
 */
global define boolean Import(map settings) ``{

    DNS::Import(eval(settings["dns"]:$[]));
    Routing::Import(eval(settings["routing"]:$[]));
    Devices = eval(settings["devices"]:$[]);
    Modules = eval(settings["modules"]:$[]);

    map Global = settings["global"]:$[];
    wait_for_interfaces = Global["wait_for_interfaces"]:nil;

    modified = true;
    return true;
}

/**
 * Export data
 * @return dumped settings (later acceptable by Import())
 */
global define map Export() ``{

    return eval($[
	"dns"		: DNS::Export(),
	"routing"	: Routing::Export(),
	"devices"	: Devices,
	"modules"	: Modules,
	"global"	: $[
	    "wait_for_interfaces" : wait_for_interfaces,
	]
    ]);

}

/**
 * Select the hardware component
 * @param which index of the component
 */
global define void SelectHW(integer which) ``{
    SelectHardware(which);
}

/**
 * Create a textual summary and a list of unconfigured devices
 * @param split split configured and unconfigured?
 * @return summary of the current configuration
 */
global define list Summary(boolean split) ``{
    return BuildSummary(split);
}

/**
 * Create an overview table with all configured devices
 * @return table items
 */
global define list Overview() ``{
    return BuildOverview();
}

/*-------------------*/
/* PRIVATE FUNCTIONS */

/**
 * Return 10 free devices
 * @param type device type
 * @return list of 10 free devices
 */
global define list FreeDevices(string type) ``{
    y2debug("Devices=%1", Devices);
    return GetFreeDevices(type, 10);
}

/**
 * Return 10 free aliases
 * @param type device type
 * @param num device number
 * @return list of 10 free devices
 */
global define list FreeAliases(string type, integer num) ``{
    y2debug("Devices=%1", Devices);
    map Devices = lookup(Devices[type]:$[], sformat("%1",num), $[]);
    y2debug("Devices=%1", Devices);
    return GetFreeDevices("_aliases", 10);
}

/**
 * Select the given device
 * @param dev device to select ("" for new device, default values)
 * @return true if success
 */
global define boolean Select(string dev) ``{

    y2debug("dev=%1", dev);
    map devmap  = $[];

    /* dev=="" -> Add */
    if(dev == "") {
	type = "eth";
	device = GetFreeDevice(type);
	AddModule(type);
	/* FIXME: ? */
    }
    /* dev!="" -> Edit */
    else {
	if(!CheckDevice(dev)) {
	    y2error("Device not found: %1", dev);
	    return false;
	}
	devmap = lookup(Devices[type]:$[], device, $[]);
    }

    /* general stuff */
    name = devmap["NAME"]:"";
    unique = devmap["UNIQUE"]:"";

    /* address options */
    bootproto = devmap["BOOTPROTO"]:"static";
    ipaddr = devmap["IPADDR"]:(Detection::result["IPADDR"]:"");
    remoteip = devmap["REMOTE_IPADDR"]:"";
    netmask = devmap["NETMASK"]:(Detection::result["NETMASK"]:"255.255.255.0");
    mtu = devmap["MTU"]:"";

    /* wireless options */
    // FIXME: wlan wireless = devmap["WIRELESS"]:"no" == "yes";
    wl_mode = devmap["WIRELESS_MODE"]:"";
    wl_essid = devmap["WIRELESS_ESSID"]:"";
    wl_nwid = devmap["WIRELESS_NWID"]:"";
    wl_key = devmap["WIRELESS_KEY"]:"";
    wl_nick = devmap["WIRELESS_NICK"]:"";

    /* s/390 options */
    read_channel = devmap["READ_CHANNEL"]:"";
    write_channel = devmap["WRITE_CHANNEL"]:"";
    data_channel = devmap["DATA_CHANNEL"]:"";
    portname = devmap["PORTNAME"]:"";

    hotplug = "";
    if(issubstring(type, "pcmcia"))
	hotplug = "pcmcia";
    else if(issubstring(type, "usb"))
	hotplug = "usb";

    y2debug("type=%1", type);
    if(issubstring(type, "-"))
	type = regexpsub(type, "([^-]+)-.*$", "\\1");
    y2debug("type=%1", type);

    /* kernel options */
    if(hotplug == "")
	SelectModule(dev);

    if(bootproto == "none") bootproto = "static";

    return true;
}

/**
 * Add a new device
 * @return true if success
 */
global define boolean Add() ``{
    operation = nil;
    if(Select("") != true) return false;
    operation = `add;
    return true;
}

/**
 * Edit the given device
 * @param dev device to edit
 * @return true if success
 */
global define boolean Edit(string dev) ``{
    operation = nil;
    if(Select(dev) != true) return false;
    operation = `edit;
    return true;
}

/**
 * Delete the given device
 * @param dev device to delete
 * @return true if success
 */
global define boolean Delete(string dev) ``{
    operation = nil;
    if(!CheckDevice(dev)) {
	y2error("Device not found: %1", dev);
	return false;
    }
    operation = `delete;
    return true;
}

/**
 * Commit pending operation
 * @return true if success
 */
global define boolean Commit() ``{
    y2debug("Commit(%1)", operation);

    if(operation == `add || operation == `edit) {
	map newdev = $[
	    "BOOTPROTO"	: bootproto,
	    "UNIQUE"	: unique,
	];
	//if(bootproto == "static") {
	if(ipaddr != "") {
	    change(newdev, "IPADDR", ipaddr);
	    change(newdev, "NETMASK", netmask);
	    change(newdev, "BROADCAST", compute_broadcast(ipaddr, netmask));
	    change(newdev, "NETWORK", compute_network(ipaddr, netmask));
	}
	change(newdev, "REMOTE_IPADDR", remoteip);
	change(newdev, "MTU", mtu);

	if(hotplug == "") {
	    change(newdev, "STARTMODE", "onboot");
	    ChangeModule(device_name(type, device), operation == `add);
	}
	else
	    change(newdev, "STARTMODE", "hotplug");

	if(hotplug == "pcmcia")
	    change(newdev, "DHCLIENT_SET_DOWN_LINK", "yes");

	if(type == "wlan") {
	    // FIXME: wlan change(newdev, "WIRELESS", "yes");
	    change(newdev, "WIRELESS_MODE", wl_mode);
	    change(newdev, "WIRELESS_ESSID", wl_essid);
	    change(newdev, "WIRELESS_NWID", wl_nwid);
	    change(newdev, "WIRELESS_KEY", wl_key);
	    change(newdev, "WIRELESS_NICK", wl_nick);
	}
	else
	    change(newdev, "WIRELESS", "no");

	if(Arch::s390) {
	    /* s390 options */
	    change(newdev, "READ_CHANNEL", read_channel);
	    change(newdev, "WRITE_CHANNEL", write_channel);
	    change(newdev, "DATA_CHANNEL", data_channel);
	    change(newdev, "PORTNAME", portname);
	}

	if(type == "ctc" || type == "escon")
	    if(wait_for_interfaces == nil || wait_for_interfaces < 40)
		wait_for_interfaces = 40;

	if(type == "hsi" || Module["module"]:"" == "qeth")
	    if(wait_for_interfaces == nil || wait_for_interfaces < 15)
		wait_for_interfaces = 15;

	ChangeDevice2(device_name(RealType(type, hotplug), device), newdev, operation == `add);
    }
    else if(operation == `delete) {
	if(hotplug == "") DeleteModule(type+device);
	DeleteDevice2(type+device);
    }
    else {
	y2error("Unknown operation: %1", operation);
	return false;
    }

    modified = true;
    operation = nil;
    return true;
}

/**
 * Propose a configuration
 * @return true if something was proposed
 */
global define boolean Propose() ``{

    y2milestone("Devices=%1", Devices);
    y2milestone("Hardware=%1", Hardware);
    y2milestone("InstallInf=%1", InstallInf);

    /* Something is already configured -> do nothing */
    if(size(Devices) > 0) {
	y2milestone("Something already configured: don't propose.");
	return false;
    }

    Add();

    /* Some HW found -> use it for proposal */
    if(size(Hardware) > 0) {

	/* Select the first active */
	integer i = 0;
	integer tosel = -1;
	maplist(map h, Hardware, ``{
	    if(h["active"]:false == true)
		if(tosel == -1) tosel = i;
	    i = i + 1;
	});

	/* No active driver -> use the first */
	if(tosel == -1) tosel = 0;

	y2debug("Hardware=%1", Hardware);
	y2debug("tosel=%1", tosel);

	SelectHW(tosel);
    }
    /* Nothing detected -> use InstallInf */
    else if(size(InstallInf) > 0) {

	if(!haskey(InstallInf, "module")) {
	    y2debug("No hardware, no install.inf module -> no proposal.");
	    return false;
	}

	Module["module"] = InstallInf["module"]:"";
	Module["options"] = InstallInf["options"]:"";

	type = InstallInf["type"]:"eth";
	device = GetFreeDevice(type);
    }
    else {
	y2debug("No hardware, no install.inf -> no proposal.");
	return false;
    }

    ipaddr = InstallInf["ipaddr"]:"";
    bootproto = InstallInf["bootproto"]:"static";
    y2debug("ipaddr,bootproto=%1,%2", ipaddr, bootproto);
    if(bootproto == "static" && ipaddr != "" && ipaddr != nil) {

	y2debug("static proposal");

	/* propose address setup from /etc/install.inf */
	netmask = InstallInf["netmask"]:"";
	if(netmask == nil || netmask == "")
	    netmask = "255.255.255.0";

	/* propose default gateway from /etc/install.inf */
	string gw = InstallInf["gateway"]:"";
	if(gw != "" && gw != nil) {
	    Routing::routes = [ $[
		"destination"       : "default",
		"gateway"           : gw,
		"netmask"           : "-",
		"device"            : "-"
	    ] ];
	    Routing::modified = true;
	}

	/* propose DNS setup from /etc/install.inf */
	string ns = InstallInf["nameserver"]:"";
	string hn = InstallInf["hostname"]:"";
	string dn = InstallInf["domain"]:"";

	/* try to get hostname from the network */
	if(hn == "") {
	    string command = "/usr/bin/getent hosts \"%1\" | sed \"s/^[0-9.: \t]\\+//g\"";
	    map getent = SCR::Execute(.target.bash_output, sformat(command, ipaddr));
	    string hnent = getent["stdout"]:"";
	    y2debug("%1", hnent);
	    hnent = select(splitstring(hnent, " "), 0, "");
	    list hnsplit = split_fqhostname(hnent);
	    hn = hnsplit[0]:hn;
	    y2debug("%1", hn);
	    hnent = hnsplit[1]:"";
	    if(hnent != "" && hnent != nil)
		dn = hnent;
	    y2debug("hn=%1", hn);
	    y2debug("dn=%1", dn);
	}

	/* commit the DNS setup */
	if(ns != "" && ns != nil) {
	    DNS::nameservers = [ ns ];
	    DNS::modified = true;
	}
	if(hn != "" && hn != nil) {
	    if(dn != "" && dn != nil)
		DNS::domain = dn;
	    DNS::hostname = hn;
	    DNS::modified = true;
	}

    }
    else {
	/* Propose static config in case of DSL hardware is found */
	list pppoe = SCR::Read(.probe.pppoe);
	map pppoedev = pppoe[0]:$[];
	y2debug("pppoe=%1", pppoe);
	if(pppoe != nil && size(pppoe) > 0) {
	    y2debug("DSL proposal");
	    ipaddr = "";
	    bootproto = "static";
	}
	else {
	    y2debug("DHCP proposal");
	    ipaddr = "";
	    bootproto = "dhcp";
	    DNS::dhcp_hostname = true;
	    DNS::modified = true;
	}

    }

    Commit();
    y2milestone("Devices=%1", Devices);
    return true;
}

/**
 * Check if any device except the current one is configured with DHCP.
 * The current one is checked separately because there may be uncommitted
 * changes. (#17391)
 * @return true if any DHCP device except the current one is configured
 */
global define boolean AnyDHCPDevice() ``{
    list devs = LocateDevices("BOOTPROTO", "dhcp");
    // The current is type+device
    devs = filter(string dev, devs, ``( dev != type + device ));
    return size(devs) > 0;
}

/**
 * Get devices of the given type
 * @param type devices type
 * @return list of found devices
 */
global define list GetDevices(string type) ``{

    if(type == nil || type == "") return [];

    list ret = [];
    if(type == "all") {
	maplist(string t, map d, Devices, ``{
	    maplist(string n, mapkeys(d), ``(change(ret, device_name(t,n))));
	});
    }
    else {
	map d = Devices[type]:$[];
	maplist(string n, mapkeys(d), ``(change(ret, device_name(type,n))));
    }

    y2debug("ret=%1", ret);
    return ret;
}

/* EOF */
}
