/**
 * File:	modules/Lan.ycp
 * Package:	Configuration of network
 * Summary:	Data for configuration of network card
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of network cards.
 * Input and output routines.
 */

{

module "Lan";
textdomain "network";

import "DNS";
import "Routing";
import "Firewall";
import "Progress";
import "Summary";

include "network/config.ycp";
include "network/hardware.ycp";
include "network/routines.ycp";
include "network/summary.ycp";
include "network/runtime.ycp";
include "network/ip.ycp";

/*-------------*/
/* GLOBAL DATA */

/* kernel options */
global string name = "";
global string modul = "";
global string options = "";
global string unique = "";
global string type = "";

global boolean pcmcia = false;
global boolean usb = false;

/* address options */
global string bootproto = "static";
global string ipaddr = "";
global string netmask = "";
global integer device = -1;

global boolean proposal_valid = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global block AbortFunction = nil;

/*--------------*/
/* PRIVATE DATA */

/**
 * Hardware information
 * @see ReadHardware
 */
list HARDWARE = [];

/**
 * Config information
 * @see ReadConfig
 */
map CONFIG = $[];

/**
 * Deleted devices
 */
list DELETED = [];

/**
 * /etc/install.inf data
 */
map INSTALL_INF = $[];

/**
 * Data was modified?
 */
boolean modified = false;

/**
 * Which operation is pending?
 */
symbol operation = nil;

/*------------------*/
/* GLOBAL FUNCTIONS */

/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() ``{
    y2debug("modified=%1",modified);
    return modified;
};

/**
 * Read all network settings from the SCR
 * @return true on success
 */
global define boolean Read() ``{

    string caption = _("Initializing network configuration");
    integer steps = 7;

    /* FIXME */
    integer sl = 0; //1000;
    sleep(sl);

    Progress::New(caption, " ", steps, [
	_("Detect devices"),
	_("Read current configuration"),
	_("Read routing configuration"),
	_("Read host name and DNS configuration"),
	_("Read installation information"),
	_("Read firewall settings"),
	_("Detect current status"),
    ], [], "");

    if(Abort()) return false;
    ProgressNextStage(_("Detecting network cards"));
    //ReadHardware("");
    ReadHardware("netcard");
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Reading current configuration"));
    //ReadConfig("");
    ReadConfig("eth|eth-pcmcia-|eth-usb-|tr|tr-pcmcia-|tr-usb-");
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Reading routing configuration"));
    Routing::Read();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Reading host name and DNS configuration"));
    DNS::Read();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Reading installation information"));
    if(SCR::Read(.target.size,"/etc/install.inf") > 0)
	INSTALL_INF = SCR::Read(.etc.install_inf);
    //ReadInstallInf();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Reading firewall settings"));
    Firewall::Read();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Detecting current status"));
    ReadStatus();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}

/**
 * Only write configuration without starting any init scripts and SuSEconfig
 * @return true on success
 */
global define boolean WriteOnly()``{
       WriteConfig();
       WriteModulesConf();
       Routing::Write();
       DNS::Write();
       return true;
}

/**
 * Update the SCR according to network settings
 * @return true on success
 */
global define boolean Write() ``{

    if(!modified) return true;
    y2milestone("Writing configuration");

    string caption = _("Saving network configuration");
    integer steps = 8;

    /* FIXME */
    integer sl = 0; //1000;
    sleep(sl);

    Progress::New(caption, " ", steps, [
	_("Deactivate local network services"),
	_("Write configuration"),
	_("Write drivers information"),
	_("Write routing configuration"),
	_("Write host name and DNS configuration"),
	_("Write firewall settings"),
	_("Run SuSEconfig"),
	_("Activate local network services"),
    ], [], "");

    if(Abort()) return false;
    ProgressNextStage(_("Deactivating local network services"));
    StopNetwork();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Writing configuration"));
    WriteConfig();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Writing /etc/modules.conf"));
    WriteModulesConf();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Writing routing configuration"));
    Routing::Write();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Writing host name and DNS configuration"));
    DNS::Write();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Writing firewall settings"));
    Firewall::Write();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Running SuSEconfig"));
    RunSuSEconfig();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Activating local network services"));
    StartNetwork();
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Get all network settings from the first parameter
 * (for use by autoinstallation)
 * @param settings a map of settings to be imported.
 * @return true on success
 */
global define boolean Import(map settings) ``{
    map interfaces = listmap(map interface, settings["interfaces"]:[],``{
	string upcase = "bootproto broadcast ipaddr netmask network startmode";
	string ignore = "UNIQUE";
	map new_interface = mapmap(`k,`v, interface, ``{
	    if (issubstring(upcase, k)) {
		return([toupper(k),v]);
	    }
	    else if (!issubstring(ignore, k)) {
		return([k,v]);
	    }
	});
	return([interface["device"]:"unknown",new_interface]);
    });
    map eth = $[];
    map token = $[];
    foreach(string device, map if_data, interfaces, ``{
	if (issubstring(device, "eth")) {
	    eth=add(eth,substring(device,3), if_data);
	} else if (issubstring(device, "tr")) {
	    token=add(token,substring(device,2), if_data);
	}
    });

    CONFIG=eval($["eth":eth,"tr":token]);
    DNS::Import(eval(settings["dns"]:$[]));
    Routing::Import(eval(settings["routing"]:$[]));
    return true;
}

/**
 * Dump the network settings to a single map
 * (for use by autoinstallation)
 * @return dumped settings (later acceptable by Import())
 */
global define map Export() ``{
    list autoinst_cfg = [];

    string upcase = "BOOTPROTO BROADCAST IPADDR NETMASK NETWORK STARTMODE";
    string ignore = "UNIQUE";

    foreach(string device, map data, CONFIG, ``{
	list interfaces = maplist(string device_nr, map device_data, data, ``{
	    device_data = add(device_data,"device", device + device_nr);
	    map new_device = mapmap(`k,`v, device_data, ``{
		if (issubstring(upcase, k)) {
		    return([tolower(k),v]);
		}
		else if (!issubstring(ignore, k)) {
		    return([k,v]);
		}
	    });
	    return(new_device);
	});
	autoinst_cfg=union( autoinst_cfg, interfaces);
    });
    return eval($[
	"interfaces":autoinst_cfg,
	"dns":DNS::Export(),
	"routing":Routing::Export()
    ]);
}

/**
 * Select the hardware component
 * @param which index of the component
 */
global define void Select(integer which) ``{
    SelectHardware(which);
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @param split split configured and unconfigured?
 * @return summary of the current configuration
 */
global define list Summary(boolean split) ``{
    return BuildSummary(split);
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global define list Overview() ``{
    return BuildOverview();
}

/*-------------------*/
/* PRIVATE FUNCTIONS */

/**
 * Abort function
 * @return blah blah lahjk
 */
define boolean Abort() ``{
    if(AbortFunction != nil)
	return eval(AbortFunction) == true;
    return false;
}

/**
 * Return 10 free devices
 * @param type device type
 * @return list of 10 free devices
 */
global define list FreeDevices(string type) ``{
    y2debug("CONFIG=%1",CONFIG);
    return GetFreeDevices(type, 10);
}

/**
 * Add a new device or edit existing (prepare before Commit)
 * @param dev device to edit
 * @return true if success
 */
global define boolean AddEdit(string dev) ``{
    operation = nil;
    map devmap  = $[];

    /* dev=="" -> Add */
    if(dev == "") {
        type = "eth";
        device = select(GetFreeDevices(type,1), 0, -1);
	operation = `add;
    }
    /* dev!="" -> Edit */
    else {
        string typ = device_type(dev);
        integer num = device_num(dev);
        string n = sformat("%1",num);

        map typemap = lookup(CONFIG, typ, $[]);
        if(!haskey(typemap, n)) {
            y2error("Key not found: %1", dev);
            return false;
        }
        devmap = lookup(typemap, n, $[]);

        type = typ;
        device = num;
	operation = `edit;
    }

    /* general stuff */
    name = devmap["NAME"]:"";
    unique = devmap["UNIQUE"]:"";

    /* address options */
    bootproto = devmap["BOOTPROTO"]:"static";
    ipaddr = devmap["IPADDR"]:"";
    netmask = devmap["NETMASK"]:"";

    /* kernel options */
    modul = devmap["module"]:"";
    options = devmap["options"]:"";

    pcmcia = false;
    usb = false;
    if(issubstring(type, "pcmcia"))
	pcmcia = true;
    else if(issubstring(type, "usb"))
	usb = true;

    if(bootproto == "" || bootproto == "none") bootproto = "static";

    return true;
}

/**
 * Delete the given device
 * @param dev device to edit
 * @return true if success
 */
global define boolean Delete(string dev) ``{
    operation = nil;
    string typ = device_type(dev);
    integer num = device_num(dev);

    map typemap = lookup(CONFIG, typ, $[]);
    if(!haskey(typemap, sformat("%1",num))) {
	y2error("Key not found: %1", dev);
	return false;
    }

    type = typ;
    device = num;
    operation = `delete;
    return true;
}

/**
 * Commit pending operation
 * @return true if success
 * @see AddEdit
 */
global define boolean Commit() ``{
    y2debug("Commit(%1)",operation);

    if(operation == `add || operation == `edit) {
	map newdev = $[
	    "BOOTPROTO"	: bootproto,
	    "UNIQUE"	: unique,
	];
	//if(bootproto == "static") {
	if(ipaddr != "") {
	    change(newdev, "IPADDR", ipaddr);
	    change(newdev, "NETMASK", netmask);
	    change(newdev, "BROADCAST", compute_broadcast(ipaddr, netmask));
	    change(newdev, "NETWORK", compute_network(ipaddr, netmask));
	}
	if(pcmcia||usb)
	    change(newdev, "STARTMODE", "hotplug");
	else
	    change(newdev, "STARTMODE", "onboot");
	if(pcmcia)
	    change(newdev, "DHCLIENT_SET_DOWN_LINK", "yes");
	change(newdev, "module", modul);
	change(newdev, "options", options);
	if(operation == `add)
	    ConfigAdd(type, device, newdev, true);
	else
	    ConfigAdd(type, device, newdev, false);
    }
    else if(operation == `delete) {
	ConfigDelete(type, device);
	change(DELETED, type+device);
    }
    else {
	y2error("Unknown operation: %1", operation);
	return false;
    }

    modified = true;
    operation = nil;
    return true;
}

/**
 * Check if any device is configured with DHCP
 * @return true if any DHCP device is configured
 */
global define boolean AnyDHCPDevice() ``{
    list devs = LocateDevices("BOOTPROTO", "dhcp");
    if(size(devs) > 0) return true;
    return false;
}

/* EOF */
}
