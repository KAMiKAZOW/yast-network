/**
 * File:	modules/Lan.ycp
 * Package:	Configuration of network
 * Summary:	Data for configuration of network card
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of network cards.
 * Input and output routines.
 */

{

module "Lan";
textdomain "network";

import "DNS";
import "Routing";
import "Firewall";
import "Progress";
import "Summary";

include "network/complex.ycp";
include "network/config.ycp";
include "network/hardware.ycp";
include "network/ip.ycp";
include "network/routines.ycp";
include "network/runtime.ycp";

/*-------------*/
/* GLOBAL DATA */

/* kernel options */
global string name = "";
global string modul = "";
global string options = "";
global string unique = "";
global string type = "";

global boolean pcmcia = false;
global boolean usb = false;

/* address options */
global string bootproto = "static";
global string ipaddr = "";
global string netmask = "";
global integer device = -1;

/* wireless options */
global boolean wireless = false;
global string wl_mode = "";
global string wl_essid = "";
global string wl_nwid = "";
global string wl_key = "";
global string wl_nick = "";

/* FIXME */
global boolean proposal_valid = false;
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global block AbortFunction = nil;

/*--------------*/
/* PRIVATE DATA */

/**
 * Hardware information
 * @see ReadHardware
 */
list HARDWARE = [];

/**
 * Config information
 * @see ReadConfig
 */
map CONFIG = $[];

/**
 * Deleted devices
 */
list DELETED = [];

/**
 * /etc/install.inf data
 */
map INSTALL_INF = $[];

/**
 * Data was modified?
 */
boolean modified = false;

/**
 * Which operation is pending?
 */
symbol operation = nil;

/*------------------*/
/* GLOBAL FUNCTIONS */

/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() ``{
    y2debug("modified=%1",modified);
    return modified;
};

/**
 * Read all network settings from the SCR
 * @return true on success
 */
global define boolean Read() ``{

    // title for Lan reading current setup progress screen
    string caption = _("Initializing network configuration");
    integer steps = 8;

    /* FIXME */
    integer sl = 0; //1000;
    sleep(sl);

    Progress::New(caption, " ", steps, [
    // progress steps for the Lan reading current setup progress screen
    // progress step 1/8
	_("Detect devices"),
    // progress step 2/8
	_("Read /etc/modules.conf"),
    // progress step 3/8
	_("Read current configuration"),
    // progress step 4/8
	_("Read routing configuration"),
    // progress step 5/8
	_("Read host name and DNS configuration"),
    // progress step 6/8
	_("Read installation information"),
    // progress step 7/8
	_("Read firewall settings"),
    // progress step 8/8
	_("Detect current status"),
    ], [], "");

    if(Abort()) return false;
    // stage 1 in reading current Lan setup
    ProgressNextStage(_("Detecting network cards"));
    //ReadHardware("");
    ReadHardware("netcard");
    sleep(sl);

    if(Abort()) return false;
    // stage 2 in reading current Lan setup
    ProgressNextStage(_("Reading /etc/modules.conf"));
    ReadModules();
    sleep(sl);

    if(Abort()) return false;
    // stage 3 in reading current Lan setup
    ProgressNextStage(_("Reading current configuration"));
    //ReadConfig("");
    ReadConfig("eth|eth-pcmcia-|eth-usb-|tr|tr-pcmcia-|tr-usb-");
    sleep(sl);

    if(Abort()) return false;
    // stage 4 in reading current Lan setup
    ProgressNextStage(_("Reading routing configuration"));
    Routing::Read();
    sleep(sl);

    if(Abort()) return false;
    // stage 5 in reading current Lan setup
    ProgressNextStage(_("Reading host name and DNS configuration"));
    DNS::Read();
    sleep(sl);

    if(Abort()) return false;
    // stage 6 in reading current Lan setup
    ProgressNextStage(_("Reading installation information"));
    if(SCR::Read(.target.size,"/etc/install.inf") > 0)
	INSTALL_INF = SCR::Read(.etc.install_inf);
    if(INSTALL_INF == nil) INSTALL_INF = $[];
    //ReadInstallInf();
    sleep(sl);

    if(Abort()) return false;
    // stage 7 in reading current Lan setup
    ProgressNextStage(_("Reading firewall settings"));
    Firewall::Read();
    sleep(sl);

    if(Abort()) return false;
    // stage 8 in reading current Lan setup
    ProgressNextStage(_("Detecting current status"));
    ReadStatus();
    sleep(sl);

    if(Abort()) return false;
    // last stage in reading current Lan setup
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}

/**
 * Only write configuration without starting any init scripts and SuSEconfig
 * @return true on success
 */
global define boolean WriteOnly()``{
       write_only = true;
       return Write();
}

/**
 * Update the SCR according to network settings
 * @return true on success
 */
global define boolean Write() ``{

    if(!modified) return true;
    y2milestone("Writing configuration");

    // title for Lan writing current setup progress screen
    string caption = _("Saving network configuration");
    integer steps = 9;

    /* FIXME */
    integer sl = 0; //1000;
    sleep(sl);

    Progress::New(caption, " ", steps, [
    // progress steps for the Lan writing current setup progress screen
    // progress step 1/9
	_("Deactivate local network services"),
    // progress step 2/9
	_("Write drivers information"),
    // progress step 3/9
	_("Write configuration"),
    // progress step 4/9
	_("Write routing configuration"),
    // progress step 5/9
	_("Write host name and DNS configuration"),
    // progress step 6/9
	_("Write firewall settings"),
    // progress step 7/9
	_("Run SuSEconfig"),
    // progress step 8/9
	_("Set up network services"),
    // progress step 9/9
	_("Activate network services"),
    ], [], "");

    if(Abort()) return false;
    // stage 1 in writing current Lan setup
    ProgressNextStage(_("Deactivating local network services"));
    if(!write_only) StopNetwork();
    sleep(sl);

    if(Abort()) return false;
    // stage 2 in writing current Lan setup
    ProgressNextStage(_("Writing /etc/modules.conf"));
    WriteModules();
    sleep(sl);

    if(Abort()) return false;
    // stage 3 in writing current Lan setup
    ProgressNextStage(_("Writing configuration"));
    WriteConfig();
    sleep(sl);

    if(Abort()) return false;
    // stage 4 in writing current Lan setup
    ProgressNextStage(_("Writing routing configuration"));
    Routing::Write();
    sleep(sl);

    if(Abort()) return false;
    // stage 5 in writing current Lan setup
    ProgressNextStage(_("Writing host name and DNS configuration"));
    DNS::Write();
    sleep(sl);

    if(Abort()) return false;
    // stage 6 in writing current Lan setup
    ProgressNextStage(_("Writing firewall settings"));
    Firewall::Write();
    sleep(sl);

    if(Abort()) return false;
    // stage 7 in writing current Lan setup
    ProgressNextStage(_("Running SuSEconfig"));
    if(!write_only) RunSuSEconfig();
    sleep(sl);

    if(Abort()) return false;
    // stage 8 in writing current Lan setup
    ProgressNextStage(_("Setting up network services"));
    SetupNetwork();
    sleep(sl);

    if(Abort()) return false;
    // stage 1 in writing current Lan setup
    ProgressNextStage(_("Activating network services"));
    if(!write_only) StartNetwork();
    sleep(sl);

    if(Abort()) return false;
    // last stage in writing current Lan setup
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Get all network settings from the first parameter
 * (for use by autoinstallation)
 * @param settings a map of settings to be imported.
 * @return true on success
 */
global define boolean Import(map settings) ``{
    map interfaces = listmap(map interface, settings["interfaces"]:[],``{
	list upcase = [
					  "bootproto",
					  "broadcast",
					  "ipaddr",
					  "netmask",
					  "network",
					  "startmode",
					  "dhclient_set_down_link",
					  "wireless",
					  "wireless_mode",
					  "wireless_essid",
					  "wireless_nwid",
					  "wireless_key",
					  "wireless_nick"
					];
	map new_interface = mapmap(`k,`v, interface, ``{
	    if (contains(upcase, k)) {
		return([toupper(k),v]);
	    }
	    else {
		return([k,v]);
	    }
	});
	return([interface["device"]:"unknown",new_interface]);
    });
    map eth = $[];
    map token = $[];
    foreach(string device, map if_data, interfaces, ``{
	if (issubstring(device, "eth")) {
	    eth=add(eth,substring(device,3), if_data);
	} else if (issubstring(device, "tr")) {
	    token=add(token,substring(device,2), if_data);
	}
    });

    CONFIG = eval($["eth":eth, "tr":token]);
    DNS::Import(eval(settings["dns"]:$[]));
    Routing::Import(eval(settings["routing"]:$[]));
	modified = true;
    return true;
}

/**
 * Dump the network settings to a single map
 * (for use by autoinstallation)
 * @return dumped settings (later acceptable by Import())
 */
global define map Export() ``{
    list autoinst_cfg = [];
    list upcase = [ "BOOTPROTO", "BROADCAST", "IPADDR", "NETMASK", "NETWORK", "STARTMODE", "DHCLIENT_SET_DOWN_LINK",
					"WIRELESS", "WIRELESS_MODE", "WIRELESS_ESSID", "WIRELESS_NWID", "WIRELESS_KEY", "WIRELESS_NICK" ];
    list ignore = [ "UNIQUE" ];

    foreach(string device, map data, CONFIG, ``{
	list interfaces = maplist(string device_nr, map device_data, data, ``{
	    map new_device = $[];
	    new_device = add(new_device,"device", device + device_nr);
	    foreach(`k,`v, device_data, ``{
		if (contains(upcase, k)) {
		    new_device[tolower(k)] = v;
		}
		else if (!contains(ignore, k)) {
		    new_device[k] = v;
		}
	    });
	    return(new_device);
	});
	autoinst_cfg=union( autoinst_cfg, interfaces);
    });

    return eval($[
	"interfaces"	: autoinst_cfg,
	"dns"		: DNS::Export(),
	"routing"	: Routing::Export(),
    ]);
}

/**
 * Select the hardware component
 * @param which index of the component
 */
global define void Select(integer which) ``{
    SelectHardware(which);
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @param split split configured and unconfigured?
 * @return summary of the current configuration
 */
global define list Summary(boolean split) ``{
    return BuildSummary(split);
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global define list Overview() ``{
    return BuildOverview();
}

/*-------------------*/
/* PRIVATE FUNCTIONS */

/**
 * Return 10 free devices
 * @param type device type
 * @return list of 10 free devices
 */
global define list FreeDevices(string type) ``{
    y2debug("CONFIG=%1",CONFIG);
    return GetFreeDevices(type, 10);
}

/**
 * Return 10 free aliases
 * @param type device type
 * @param num device number
 * @return list of 10 free devices
 */
global define list FreeAliases(string type, integer num) ``{
    y2debug("CONFIG=%1",CONFIG);
    map CONFIG = lookup(lookup(CONFIG, type, $[]), sformat("%1",num), $[]);
    y2debug("CONFIG=%1",CONFIG);
    return GetFreeDevices("_aliases", 10);
}

/**
 * Add a new device or edit an existing one (prepare before Commit)
 * @param dev device to edit, "" means to add one
 * @return true if success
 */
global define boolean AddEdit(string dev) ``{
    operation = nil;
    map devmap  = $[];

    /* dev=="" -> Add */
    if(dev == "") {
        type = "eth";
        device = GetFreeDevice(type);
	operation = `add;
    }
    /* dev!="" -> Edit */
    else {
        string typ = device_type(dev);
        integer num = device_num(dev);
        string n = sformat("%1",num);

        map typemap = lookup(CONFIG, typ, $[]);
        if(!haskey(typemap, n)) {
            y2error("Key not found: %1", dev);
            return false;
        }
        devmap = lookup(typemap, n, $[]);

        type = typ;
        device = num;
	operation = `edit;
    }

    /* general stuff */
    name = devmap["NAME"]:"";
    unique = devmap["UNIQUE"]:"";

    /* address options */
    bootproto = devmap["BOOTPROTO"]:"static";
    ipaddr = devmap["IPADDR"]:"";
    netmask = devmap["NETMASK"]:"";

    /* kernel options */
    modul = devmap["module"]:"";
    options = devmap["options"]:"";

    /* wireless options */
    wireless = devmap["WIRELESS"]:"no" == "yes";
    wl_mode = devmap["WIRELESS_MODE"]:"";
    wl_essid = devmap["WIRELESS_ESSID"]:"";
    wl_nwid = devmap["WIRELESS_NWID"]:"";
    wl_key = devmap["WIRELESS_KEY"]:"";
    wl_nick = devmap["WIRELESS_NICK"]:"";

    pcmcia = false;
    usb = false;
    if(issubstring(type, "pcmcia"))
	pcmcia = true;
    else if(issubstring(type, "usb"))
	usb = true;

    if(bootproto == "" || bootproto == "none") bootproto = "static";

    return true;
}

/**
 * Delete the given device
 * @param dev device to edit
 * @return true if success
 */
global define boolean Delete(string dev) ``{
    operation = nil;
    string typ = device_type(dev);
    integer num = device_num(dev);

    map typemap = lookup(CONFIG, typ, $[]);
    if(!haskey(typemap, sformat("%1",num))) {
	y2error("Key not found: %1", dev);
	return false;
    }

    type = typ;
    device = num;
    operation = `delete;
    return true;
}

/**
 * Commit pending operation
 * @return true if success
 * @see AddEdit
 */
global define boolean Commit() ``{
    y2debug("Commit(%1)",operation);

    if(operation == `add || operation == `edit) {
	map newdev = $[
	    "BOOTPROTO"	: bootproto,
	    "UNIQUE"	: unique,
	];
	//if(bootproto == "static") {
	if(ipaddr != "") {
	    change(newdev, "IPADDR", ipaddr);
	    change(newdev, "NETMASK", netmask);
	    change(newdev, "BROADCAST", compute_broadcast(ipaddr, netmask));
	    change(newdev, "NETWORK", compute_network(ipaddr, netmask));
	}
	if(pcmcia||usb)
	    change(newdev, "STARTMODE", "hotplug");
	else
	    change(newdev, "STARTMODE", "onboot");
	if(pcmcia)
	    change(newdev, "DHCLIENT_SET_DOWN_LINK", "yes");
	change(newdev, "module", modul);
	change(newdev, "options", options);

	if(wireless) {
	    change(newdev, "WIRELESS", "yes");
	    change(newdev, "WIRELESS_MODE", wl_mode);
	    change(newdev, "WIRELESS_ESSID", wl_essid);
	    change(newdev, "WIRELESS_NWID", wl_nwid);
	    change(newdev, "WIRELESS_KEY", wl_key);
	    change(newdev, "WIRELESS_NICK", wl_nick);
	}
	else
	    change(newdev, "WIRELESS", "no");

	if(operation == `add)
	    ConfigAddEdit(type, device, newdev, true);
	else
	    ConfigAddEdit(type, device, newdev, false);
    }
    else if(operation == `delete) {
	ConfigDelete(type, device);
	change(DELETED, type+device);
    }
    else {
	y2error("Unknown operation: %1", operation);
	return false;
    }

    modified = true;
    operation = nil;
    return true;
}

/**
 * Propose a configuration
 */
global define void Propose() ``{

    y2milestone("CONFIG=%1", CONFIG);
    y2milestone("HARDWARE=%1", HARDWARE);
    y2milestone("INSTALL_INF=%1", INSTALL_INF);

    /* Something is already configured -> do nothing */
    if(size(CONFIG) > 0) {
	y2milestone("Something already configured: don't propose");
	return;
    }

    if(INSTALL_INF == nil) INSTALL_INF = $[];
    AddEdit("");

    /* Some HW found -> use the first */
    if(size(HARDWARE) > 0) {
	Select(0);
    }
    /* Nothing detected -> use INSTALL_INF */
    else {
	return;
	/* placeholder for s390 and others without autodetected HW
	Select(nil);
	modul = INSTALL_INF["Alias"]:"";
	options = INSTALL_INF["Options"]:"";
	type = INSTALL_INF["xxx"]:"eth";
	device = GetFreeDevice(type);
	*/
    }

    string netconfig = SCR::Read(.etc.install_inf.NetConfig);
    string ip = SCR::Read(.etc.install_inf.IP);
    if (netconfig == "static" && ip != nil && ip != "") {

	/* propose address setup from /etc/install.inf */
	bootproto = "static";
	ipaddr = ip;
	netmask = SCR::Read(.etc.install_inf.Netmask);
	if(netmask == nil || netmask == "")
	    netmask = "255.255.255.0";

	/* propose default gateway from /etc/install.inf */
	string gw = SCR::Read(.etc.install_inf.Gateway);
	if(gw != "" && gw != nil) {
	    Routing::routes = [ $[
		"destination"       : "default",
		"gateway"           : gw,
		"netmask"           : "-",
		"device"            : "-"
	    ] ];
	    Routing::modified = true;
	}

	/* propose DNS setup from /etc/install.inf */
	string ns = SCR::Read(.etc.install_inf.Nameserver);
	string mn = SCR::Read(.etc.install_inf.Machinename);
	string dn = SCR::Read(.etc.install_inf.Domainname);
	if(ns != "" && ns != nil) DNS::nameservers = [ ns ];
	if(mn != "" && dn != "" && dn != nil && mn != nil) {
	    DNS::hostname = mn;
	    DNS::domain = dn;
	}
	DNS::modified = true;

    }
    else {
	bootproto = "dhcp";	// or bootproto = netconfig?
	DNS::dhcp_hostname = true;
	DNS::modified = true;
    }

    Commit();
    y2milestone("CONFIG=%1", CONFIG);
}

/**
 * Check if any device except the current one is configured with DHCP.
 * The current one is checked separately because there may be uncommitted
 * changes. (#17391)
 * @return true if any DHCP device except the current one is configured
 */
global define boolean AnyDHCPDevice() ``{
    list devs = LocateDevices("BOOTPROTO", "dhcp");
    // The current is type+device
    devs = filter (string dev, devs, ``( dev != type + device ));
    if(size(devs) > 0) return true;
    return false;
}

/* EOF */
}
