/**
 * File:	modules/Lan.ycp
 * Package:	Network configuration
 * Summary:	Network card data
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of network cards.
 * Input and output routines.
 */

{

module "Lan";
textdomain "network";

import "Arch";
import "DNS";
import "Routing";
import "Firewall";
import "Progress";
import "Summary";

include "network/complex.ycp";
include "network/devices.ycp";
include "network/hardware.ycp";
include "network/ip.ycp";
include "network/modules.ycp";
include "network/routines.ycp";
include "network/runtime.ycp";

/*-------------*/
/* GLOBAL DATA */

/**
 * Current module information
 */
global map Module = $[];

global string name = "";
global string unique = "";
global string type = "";

/**
 * Hotplug type ("" if not hot pluggable)
 */
global string hotplug = "";

/* address options */
global string bootproto = "static";
global string ipaddr = "";
global string remoteip = "";
global string netmask = "";
global integer device = -1;

/* wireless options */
global boolean wireless = false;
global string wl_mode = "";
global string wl_essid = "";
global string wl_nwid = "";
global string wl_key = "";
global string wl_nick = "";

/* s390 options */
global string read_channel = "";
global string write_channel = "";
global string data_channel = "";
global string portname = "";

/* global options */
global integer wait_for_interfaces = nil;

/* FIXME */
global boolean proposal_valid = false;
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global block AbortFunction = nil;

/*--------------*/
/* PRIVATE DATA */

/**
 * Hardware information
 * @see ReadHardware
 */
list HARDWARE = [];

/**
 * Devices information
 * @see ReadDevices
 */
map Devices = $[];

/**
 * Deleted devices
 */
list DeletedDevices = [];

/**
 * Modules information
 * @see ReadModules
 */
map Modules = $[];

/**
 * Deleted modules
 */
list DeletedModules = [];

/**
 * /etc/install.inf data
 */
map INSTALL_INF = $[];

/**
 * Data was modified?
 */
boolean modified = false;

/**
 * Which operation is pending?
 */
global symbol operation = nil;
// FIXME: used in lan/address.ycp (#17346) -> "global"

/*------------------*/
/* GLOBAL FUNCTIONS */

/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() ``{
    y2debug("modified=%1",modified);
    return modified;
};

/**
 * Read all network settings from the SCR
 * @return true on success
 */
global define boolean Read() ``{

    /* Read dialog caption */
    string caption = _("Initializing network configuration");
    integer steps = 8;

    /* FIXME */
    integer sl = 0; //1000;
    sleep(sl);

    Progress::New(caption, " ", steps, [
	/* Progress step 1/8 */
	_("Detect network devices"),
	/* Progress step 2/8 */
	_("Read /etc/modules.conf"),
	/* Progress step 3/8 */
	_("Read current configuration"),
	/* Progress step 4/8 */
	_("Read routing configuration"),
	/* Progress step 5/8 */
	_("Read host name and DNS configuration"),
	/* Progress step 6/8 */
	_("Read installation information"),
	/* Progress step 7/8 */
	_("Read firewall settings"),
	/* Progress step 8/8 */
	_("Detect current status"),
    ], [], "");

    if(Abort()) return false;
    /* Progress stage 1/8 */
    ProgressNextStage(_("Detecting network devices"));
    if(!Arch::s390) /* FIXME: Temporary hack until the detection is functional */
	ReadHardware("netcard");
	//ReadHardware("");
    sleep(sl);

    if(Abort()) return false;
    /* Progress stage 2/8 */
    ProgressNextStage(_("Reading /etc/modules.conf"));
    ReadModules(NetworkCardRegex);
    // ReadModules("");
    sleep(sl);

    if(Abort()) return false;
    /* Progress stage 3/8 */
    ProgressNextStage(_("Reading current configuration"));
    ReadDevices(NetworkDeviceRegex);
    //ReadDevices("");
    sleep(sl);

    string wait = SCR::Read(.sysconfig.network.config.WAIT_FOR_INTERFACES);
    if(wait != "" && wait != nil) wait_for_interfaces = tointeger(wait);

    if(Abort()) return false;
    /* Progress stage 4/8 */
    ProgressNextStage(_("Reading routing configuration"));
    Routing::Read();
    sleep(sl);

    if(Abort()) return false;
    /* Progress stage 5/8 */
    ProgressNextStage(_("Reading host name and DNS configuration"));
    DNS::Read();
    sleep(sl);

    if(Abort()) return false;
    /* Progress stage 6/8 */
    ProgressNextStage(_("Reading installation information"));
    if(SCR::Read(.target.size,"/etc/install.inf") > 0)
	INSTALL_INF = SCR::Read(.etc.install_inf);
    if(INSTALL_INF == nil) INSTALL_INF = $[];
    //ReadInstallInf();
    sleep(sl);

    if(Abort()) return false;
    /* Progress stage 7/8 */
    ProgressNextStage(_("Reading firewall settings"));
    Firewall::Read();
    sleep(sl);

    if(Abort()) return false;
    /* Progress stage 8/8 */
    ProgressNextStage(_("Detecting current status"));
    ReadStatus();
    sleep(sl);

    if(Abort()) return false;
    /* Final progress stage */
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}

/**
 * Only write configuration without starting any init scripts and SuSEconfig
 * @return true on success
 */
global define boolean WriteOnly()``{
       write_only = true;
       return Write();
}

/**
 * Update the SCR according to network settings
 * @return true on success
 */
global define boolean Write() ``{

    if(!modified) return true;
    y2milestone("Writing configuration");

    /* Write dialog caption */
    string caption = _("Saving network configuration");
    integer steps = 9;

    /* FIXME */
    integer sl = 0; //1000;
    sleep(sl);

    Progress::New(caption, " ", steps, [
	/* Progress step 1/9 */
	_("Deactivate local network services"),
	/* Progress step 2/9 */
	_("Write drivers information"),
	/* Progress step 3/9 */
	_("Write configuration"),
	/* Progress step 4/9 */
	_("Write routing configuration"),
	/* Progress step 5/9 */
	_("Write host name and DNS configuration"),
	/* Progress step 6/9 */
	_("Set up network services"),
	/* Progress step 7/9 */
	_("Write firewall settings"),
	/* Progress step 8/9 */
	_("Activate network services"),
	/* Progress step 9/9 */
	_("Run SuSEconfig"),
    ], [], "");

    if(Abort()) return false;
    /* Progress stage 1/9 */
    ProgressNextStage(_("Deactivating local network services"));
    if(!write_only) StopNetwork();
    sleep(sl);

    if(Abort()) return false;
    /* Progress stage 2/9 */
    ProgressNextStage(_("Writing /etc/modules.conf"));
    WriteModules();
    sleep(sl);

    if(Abort()) return false;
    /* Progress stage 3/9 */
    ProgressNextStage(_("Writing configuration"));
    WriteDevices();
    sleep(sl);

    if(wait_for_interfaces != nil)
	SCR::Write(.sysconfig.network.config.WAIT_FOR_INTERFACES, sformat("%1",wait_for_interfaces));

    if(Abort()) return false;
    /* Progress stage 4/9 */
    ProgressNextStage(_("Writing routing configuration"));
    Routing::Write();
    sleep(sl);

    if(Abort()) return false;
    /* Progress stage 5/9 */
    ProgressNextStage(_("Writing host name and DNS configuration"));
    DNS::Write();
    sleep(sl);

    if(Abort()) return false;
    /* Progress stage 6/9 */
    ProgressNextStage(_("Setting up network services"));
    EnableNetwork();
    sleep(sl);

    if(Abort()) return false;
    /* Progress stage 7/9 */
    ProgressNextStage(_("Writing firewall settings"));
    Firewall::Write();
    sleep(sl);

    if(Abort()) return false;
    /* Progress stage 8/9 */
    ProgressNextStage(_("Activating network services"));
    if(!write_only) StartNetwork();
    sleep(sl);

    if(Abort()) return false;
    /* Progress stage 9/9 */
    ProgressNextStage(_("Running SuSEconfig"));
    if(!write_only) RunSuSEconfig();
    sleep(sl);

    if(Abort()) return false;
    /* Final progress stage */
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Import data
 * @param settings settings to be imported
 * @return true on success
 */
global define boolean Import(map settings) ``{

    DNS::Import(eval(settings["dns"]:$[]));
    Routing::Import(eval(settings["routing"]:$[]));
    Devices = eval(settings["devices"]:$[]);
    Modules = eval(settings["modules"]:$[]);

    map Global = settings["global"]:$[];
    wait_for_interfaces = Global["wait_for_interfaces"]:nil;

    modified = true;
    return true;

    /* This is broken: it ignores aliases, different HW types, ... * /

    map interfaces = listmap(map interface, settings["interfaces"]:[],``{
	map new_interface = mapmap(`k,`v, interface, ``{
	    if (contains(upcase, k)) {
		return([toupper(k),v]);
	    }
	    else {
		return([k,v]);
	    }
	});
	return([interface["device"]:"unknown",new_interface]);
    });
    map eth = $[];
    map token = $[];
    foreach(string device, map if_data, interfaces, ``{
	if (issubstring(device, "eth")) {
	    eth=add(eth,substring(device,3), if_data);
	} else if (issubstring(device, "tr")) {
	    token=add(token,substring(device,2), if_data);
	}
    });

    Devices = eval($["eth":eth, "tr":token]);
    DNS::Import(eval(settings["dns"]:$[]));
    Routing::Import(eval(settings["routing"]:$[]));
    modified = true;
    return true;
    */
}

/**
 * Export data
 * @return dumped settings (later acceptable by Import())
 */
global define map Export() ``{

    return eval($[
	"dns"		: DNS::Export(),
	"routing"	: Routing::Export(),
	"devices"	: Devices,
	"modules"	: Modules,
	"global"	: $[
	    "wait_for_interfaces" : wait_for_interfaces,
	]
    ]);

    /* This is broken: it ignores aliases, different HW types, ... * /

    list interfaces = [];
    maplist(string device, map devsmap, Devices, ``{
	maplist(string num, map devmap, devsmap, ``{
	    map newmap = $[];
	    maplist(string key, string val, devmap, ``{
		change(newmap, tolower(key), val);
	    });
	    change(newmap, "device", device+num);
	    change(interfaces, newmap);
	});
    });

    return eval($[
	"dns"		: DNS::Export(),
	"routing"	: Routing::Export(),
	"interfaces"	: interfaces,
    ]);
    */
}

/**
 * Select the hardware component
 * @param which index of the component
 */
global define void SelectHW(integer which) ``{
    SelectHardware(which);
}

/**
 * Create a textual summary and a list of unconfigured devices
 * @param split split configured and unconfigured?
 * @return summary of the current configuration
 */
global define list Summary(boolean split) ``{
    return BuildSummary(split);
}

/**
 * Create an overview table with all configured devices
 * @return table items
 */
global define list Overview() ``{
    return BuildOverview();
}

/*-------------------*/
/* PRIVATE FUNCTIONS */

/**
 * Return 10 free devices
 * @param type device type
 * @return list of 10 free devices
 */
global define list FreeDevices(string type) ``{
    y2debug("Devices=%1", Devices);
    return GetFreeDevices(type, 10);
}

/**
 * Return 10 free aliases
 * @param type device type
 * @param num device number
 * @return list of 10 free devices
 */
global define list FreeAliases(string type, integer num) ``{
    y2debug("Devices=%1", Devices);
    map Devices = lookup(Devices[type]:$[], sformat("%1",num), $[]);
    y2debug("Devices=%1", Devices);
    return GetFreeDevices("_aliases", 10);
}

/**
 * Select the given device
 * @param dev device to select ("" for new device, default values)
 * @return true if success
 */
global define boolean Select(string dev) ``{

    y2debug("dev=%1", dev);
    map devmap  = $[];

    /* dev=="" -> Add */
    if(dev == "") {
        type = "eth";
        device = GetFreeDevice(type);
	AddModule(type);
    }
    /* dev!="" -> Edit */
    else {
        string typ = device_type(dev);
        integer num = device_num(dev);
        string n = sformat("%1",num);

        map typemap = lookup(Devices, typ, $[]);
        if(!haskey(typemap, n)) {
            y2error("Key not found: %1", dev);
            return false;
        }
        devmap = lookup(typemap, n, $[]);

        type = typ;
        device = num;
    }

    /* general stuff */
    name = devmap["NAME"]:"";
    unique = devmap["UNIQUE"]:"";

    /* address options */
    bootproto = devmap["BOOTPROTO"]:"";
    ipaddr = devmap["IPADDR"]:"";
    remoteip = devmap["REMOTE_IPADDR"]:"";
    netmask = devmap["NETMASK"]:"";

    /* wireless options */
    wireless = devmap["WIRELESS"]:"no" == "yes";
    wl_mode = devmap["WIRELESS_MODE"]:"";
    wl_essid = devmap["WIRELESS_ESSID"]:"";
    wl_nwid = devmap["WIRELESS_NWID"]:"";
    wl_key = devmap["WIRELESS_KEY"]:"";
    wl_nick = devmap["WIRELESS_NICK"]:"";

    /* s/390 options */
    read_channel = devmap["READ_CHANNEL"]:"";
    write_channel = devmap["WRITE_CHANNEL"]:"";
    data_channel = devmap["DATA_CHANNEL"]:"";
    portname = devmap["PORTNAME"]:"";

    hotplug = "";
    if(issubstring(type, "pcmcia"))
	hotplug = "pcmcia";
    else if(issubstring(type, "usb"))
	hotplug = "usb";

    y2debug("type=%1", type);
    if(issubstring(type, "-"))
	type = regexpsub(type, "([^-]+)-.*$", "\\1");
    y2debug("type=%1", type);

    /* kernel options */
    if(hotplug == "")
	SelectModule(dev);

    if(bootproto == "none") bootproto = "static";

    return true;
}

/**
 * Add a new device
 * @return true if success
 */
global define boolean Add() ``{
    operation = nil;
    if(Select("") != true) return false;
    operation = `add;
    return true;
}

/**
 * Edit the given device
 * @param name device to edit
 * @return true if success
 */
global define boolean Edit(any name) ``{
    operation = nil;
    if(Select(name) != true) return false;
    operation = `edit;
    return true;
}

/**
 * Delete the given device
 * @param name device to delete
 * @return true if success
 */
global define boolean Delete(string name) ``{
    operation = nil;

    y2debug("Delete(%1)", name);
    string typ = device_type(name);
    integer num = device_num(name);

    map typemap = Devices[typ]:$[];
    if(!haskey(typemap, sformat("%1",num))) {
	y2error("Key not found: %1", name);
	return false;
    }

    type = typ;
    device = num;
    operation = `delete;
    return true;
}

/**
 * Commit pending operation
 * @return true if success
 */
global define boolean Commit() ``{
    y2debug("Commit(%1)",operation);

    if(operation == `add || operation == `edit) {
	map newdev = $[
	    "BOOTPROTO"	: bootproto,
	    "UNIQUE"	: unique,
	];
	//if(bootproto == "static") {
	if(ipaddr != "") {
	    change(newdev, "IPADDR", ipaddr);
	    change(newdev, "NETMASK", netmask);
	    change(newdev, "BROADCAST", compute_broadcast(ipaddr, netmask));
	    change(newdev, "NETWORK", compute_network(ipaddr, netmask));
	}
	change(newdev, "REMOTE_IPADDR", remoteip);

	if(hotplug == "") {
	    change(newdev, "STARTMODE", "onboot");
	    ChangeModule(type+device, operation == `add);
	}
	else
	    change(newdev, "STARTMODE", "hotplug");

	if(hotplug == "pcmcia")
	    change(newdev, "DHCLIENT_SET_DOWN_LINK", "yes");

	if(wireless) {
	    change(newdev, "WIRELESS", "yes");
	    change(newdev, "WIRELESS_MODE", wl_mode);
	    change(newdev, "WIRELESS_ESSID", wl_essid);
	    change(newdev, "WIRELESS_NWID", wl_nwid);
	    change(newdev, "WIRELESS_KEY", wl_key);
	    change(newdev, "WIRELESS_NICK", wl_nick);
	}
	else
	    change(newdev, "WIRELESS", "no");

	if(Arch::s390) {
	    /* s390 options */
	    change(newdev, "READ_CHANNEL", read_channel);
	    change(newdev, "WRITE_CHANNEL", write_channel);
	    change(newdev, "DATA_CHANNEL", data_channel);
	    change(newdev, "PORTNAME", portname);
	}

	if(type == "ctc" || type == "escon")
	    if(wait_for_interfaces == nil || wait_for_interfaces < 40)
		wait_for_interfaces = 40;

	if(type == "hsi" || Module["module"]:"" == "qeth")
	    if(wait_for_interfaces == nil || wait_for_interfaces < 15)
		wait_for_interfaces = 15;

	ChangeDevice(RealType(type, hotplug), device, newdev, operation == `add);
    }
    else if(operation == `delete) {
	DeleteModule(type+device);
	DeleteDevice(type, device);
    }
    else {
	y2error("Unknown operation: %1", operation);
	return false;
    }

    modified = true;
    operation = nil;
    return true;
}

/**
 * Propose a configuration
 */
global define void Propose() ``{

    y2milestone("Devices=%1", Devices);
    y2milestone("HARDWARE=%1", HARDWARE);
    y2milestone("INSTALL_INF=%1", INSTALL_INF);

    /* Something is already configured -> do nothing */
    if(size(Devices) > 0) {
	y2milestone("Something already configured: don't propose");
	return;
    }

    if(INSTALL_INF == nil) INSTALL_INF = $[];
    AddEdit("");

    /* Some HW found -> use it for proposal */
    if(size(HARDWARE) > 0) {

	/* Select the first active */
	integer i = 0;
	integer tosel = -1;
	maplist(`h, HARDWARE, ``{
	    if(h["active"]:false == true)
		if(tosel == -1) tosel = i;
	    i = i + 1;
	});

	/* No active driver -> use the first */
	if(tosel == -1) tosel = 0;

	y2debug("HARDWARE=%1",HARDWARE);
	y2debug("tosel=%1",tosel);

	Select(tosel);
    }
    /* Nothing detected -> use INSTALL_INF */
    else {
	return;
	/* FIXME placeholder for s390 and others without autodetected HW
	Select(nil);
	modul = INSTALL_INF["Alias"]:"";
	options = INSTALL_INF["Options"]:"";
	type = INSTALL_INF["xxx"]:"eth";
	device = GetFreeDevice(type);
	*/
    }

    string netconfig = SCR::Read(.etc.install_inf.NetConfig);
    string ip = SCR::Read(.etc.install_inf.IP);
    if (netconfig == "static" && ip != nil && ip != "") {

	/* propose address setup from /etc/install.inf */
	bootproto = "static";
	ipaddr = ip;
	netmask = SCR::Read(.etc.install_inf.Netmask);
	if(netmask == nil || netmask == "")
	    netmask = "255.255.255.0";

	/* propose default gateway from /etc/install.inf */
	string gw = SCR::Read(.etc.install_inf.Gateway);
	if(gw != "" && gw != nil) {
	    Routing::routes = [ $[
		"destination"       : "default",
		"gateway"           : gw,
		"netmask"           : "-",
		"device"            : "-"
	    ] ];
	    Routing::modified = true;
	}

	/* propose DNS setup from /etc/install.inf */
	string ns = SCR::Read(.etc.install_inf.Nameserver);
	string mn = SCR::Read(.etc.install_inf.Machinename);
	string dn = SCR::Read(.etc.install_inf.Domainname);
	if(ns != "" && ns != nil) DNS::nameservers = [ ns ];
	if(mn != "" && dn != "" && dn != nil && mn != nil) {
	    DNS::hostname = mn;
	    DNS::domain = dn;
	}
	DNS::modified = true;

    }
    else {
	bootproto = "dhcp";	// or bootproto = netconfig?
	DNS::dhcp_hostname = true;
	DNS::modified = true;
    }

    Commit();
    y2milestone("Devices=%1", Devices);
}

/**
 * Check if any device except the current one is configured with DHCP.
 * The current one is checked separately because there may be uncommitted
 * changes. (#17391)
 * @return true if any DHCP device except the current one is configured
 */
global define boolean AnyDHCPDevice() ``{
    list devs = LocateDevices("BOOTPROTO", "dhcp");
    // The current is type+device
    devs = filter (string dev, devs, ``( dev != type + device ));
    if(size(devs) > 0) return true;
    return false;
}

/* EOF */
}
