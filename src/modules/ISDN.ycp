/**
 * File:	modules/ISDN.ycp
 * Package:	Network configuration
 * Summary:	ISDN data
 * Authors:	Michal Svec  <msvec@suse.cz>
 *		Karsten Keil <kkeil@suse.de>
 *
 * $Id$
 *
 * Representation of the configuration of ISDN.
 * Input and output routines.
 */

{

module "ISDN";
textdomain "network";

import "Firewall";
import "Provider";
import "Progress";
import "Summary";

include "network/complex.ycp";
include "network/devices.ycp";
include "network/hardware.ycp";
include "network/ip.ycp";
include "network/routines.ycp";
include "network/runtime.ycp";

include "network/isdn/config.ycp";
include "network/isdn/routines.ycp";

/*-------------*/
/* GLOBAL DATA */

global boolean proposal_valid = false;

/**
 * hold current device settings
 *
 * handled items are
 * line specific
 * PROTOCOL     D-channel protocol
 * AREACODE     international area code
 * DIALPREFIX   dialprefixfor PBX setups
 * hw specific
 * PARA_IO	IO address for legacy ISA
 * PARA_MEMBASE memory base address for legacy ISA
 * PARA_IRQ     IRQ number for legacy ISA
 * PARA_TYPE    card type
 * PARA_SUBTYPE card sub type
 * NAME         full card name
 * DRIVER       driver module name
 * STARTMODE    "onboot"|"manual"|"hotplug"
 * DEBUG        debuglevel
 * UNIQUE       unique hw id
 *
 */

global map hw_device = $[];

// global dialprefix default value for current
global string global_dp="";
// global areacode default value for current
global string global_ac = "";
// global start mode
global string global_sm = "";

/* ISDN device database */
global list ISDN_Devices = [];


/**
 * hold current interface settings
 *
 * handled items are
 * IPADDR         local IP address
 * REMOTE_ADDR    remote IP address
 * DEFAULTROUTE   default route yes/no
 * DYNAMICIP      dynamic IP assignment yes/no
 * PROTOCOL       encapsulation "rawip" | "syncip"
 * MSN            own phone number
 * CHARGEHUP      try to hangup on idle just before next charge
 * CALLBACK       callback mode
 * CBDELAY        callback delay
 * STARTMODE      onboot | manual | hotplug
 * MULTILINK      channel bundling yes/no
 * PROVIDER       default provider filename
 * IPPPD_OPTIONS  additional ipppd options
 *
 */
global map interface = $[];

global string  provider_file = "";

// current item
global string  type = "";
global integer device = -1;

/**
 * Flag for Fritz!DSL configuration
 */
global boolean have_dsl = false;

/**
 * Which operation is pending?
 */
global symbol operation = nil;

/**
 * If the interface or provider configuration is skipped
 */
global boolean skip = false;

/*--------------*/
/* PRIVATE DATA */

/**
 * Hardware information
 * @see ReadHardware
 */
list Hardware = [];

/**
 * Config information
 * @see ReadDevices
 */
map Devices = $[];

/**
 * deleted devicces
 */
list DeletedDevices = [];

/**
 * Abort function
 * return boolean return true if abort
 */
global block AbortFunction = nil;

/**
 * Data was modified?
 */
boolean modified_hw = false;
boolean modified_if = false;

/*------------------*/
/* GLOBAL FUNCTIONS */

/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() ``{
    y2debug("modified(hw,if)=%1,%2", modified_hw, modified_if);
    return (modified_hw || modified_if);
}

/**
 * Read all ISDN settings from the SCR
 * @return true on success
 */
global define boolean Read() ``{
    // title for ISDN reading current setup progress screen
    string caption = _("Initializing ISDN card configuration");
    integer steps = 5;

    /* FIXME */
    integer sl = 0; //1000;
    sleep(sl);

    Progress::New(caption, " ", steps, [
    // steps for the ISDN reading current setup progress screen
    // step 1/5
	_("Detect devices"),
    // step 2/5
	_("Read current device configuration"),
    // step 3/5
	_("Read current connection setup"),
    // step 4/5
	_("Read firewall settings"),
    // step 5/5
	_("Read providers"),
    ], [], "");

    Devices = $[];

    if(Abort()) return false;
    // stage 1 in reading current ISDN setup
    ProgressNextStage(_("Detecting ISDN cards"));
    ReadHardware("isdn");
    sleep(sl);

    if(Abort()) return false;
    // stage 2 in reading current ISDN setup
    ProgressNextStage(_("Reading current device configuration"));
    ReadISDNConfig("cfg-contr");
    sleep(sl);

    if(Abort()) return false;
    // stage 3 in reading current ISDN setup
    ProgressNextStage(_("Reading current connection setup"));
    ReadISDNConfig("cfg-net");
    sleep(sl);

    if(Abort()) return false;
    // stage 4 in reading current ISDN setup
    ProgressNextStage(_("Reading firewall settings"));
    Firewall::Read();
    sleep(sl);

    if(Abort()) return false;
    // stage 5 in reading current ISDN setup
    ProgressNextStage(_("Reading providers"));
    Provider::Read("isdn");
    sleep(sl);

    if(Abort()) return false;
    // last stage in reading current ISDN setup
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    modified_hw = false;
    modified_if = false;
    return true;
}


/**
 * Only write configuration without starting any init scripts and SuSEconfig
 * @return true on success
 */

global define boolean WriteOnly()``{
    WriteISDNConfig("contr");
    WriteISDNConfig("net");
    Provider::Write();
    return true;
}

/**
 * Update the SCR according to network settings
 * @return true on success
 *
 * if start is true, load drivers and interfaces
 */
global define boolean Write(boolean start) ``{

    if(!(modified_hw || modified_if || Provider::Modified())) return true;
    y2milestone("Writing configuration");

    // title for ISDN writing current setup progress screen
    string caption = _("Saving ISDN configuration");
    integer steps = 10;
    string cmd = "";
    integer sl = 0;

    if (start) {
	steps = 12;
	Progress::New(caption, " ", steps, [
	    // steps for the ISDN writing current setup progress screen with start
        // step 1/11
	    _("Stop ISDN networking"),
        // step 2/11
	    _("Stop ISDN subsystem"),
        // step 3/11
	    _("Write controller configuration"),
        // step 4/11
	    _("Write interface configuration"),
        // step 5/11
	    _("Write Firewall"),
        // step 6/11
	    _("Write providers"),
        // step 7/11
	    _("Run SuSEconfig"),
        // step 8/11
	    _("Start ISDN subsystem"),
	// step 9/11
	    _("Set up network services"),
        // step 10/11
	    _("Set up smpppd"),
        // step 11/11
	    _("Start ISDN networking"),
        // step 12/11
	    _("Run kinternet"),
	    ], [], "");
    } else {
	steps = 7;
	Progress::New(caption, " ", steps, [
	    // steps for the ISDN writing current setup progress screen without start
        // step 1/7
	    _("Stop ISDN networking"),
        // step 2/7
	    _("Stop ISDN subsystem"),
        // step 3/7
	    _("Write controller configuration"),
        // step 4/7
	    _("Write interface configuration"),
        // step 5/7
	    _("Write Firewall"),
        // step 6/7
	    _("Write providers"),
        // step 7/7
	    _("Run SuSEconfig"),
	    ], [], "");
    }
    if(Abort()) return false;
    // stage 1 in writing current ISDN setup
    ProgressNextStage(_("Stop ISDN networking"));
    cmd = sformat("/etc/init.d/network stop -o type=isdn");
    SCR::Execute(.target.bash, cmd);
    cmd = sformat("/etc/init.d/network stop -o type=ippp");
    SCR::Execute(.target.bash, cmd);
    sleep(sl);

    if(Abort()) return false;
    // stage 2 in writing current ISDN setup
    ProgressNextStage(_("Stop ISDN subsystem"));
    if (modified_hw) {
	cmd = sformat("/etc/init.d/isdn stop");
	SCR::Execute(.target.bash, cmd);
    }
    sleep(sl);

    if(Abort()) return false;
    // stage 3 in writing current ISDN setup
    ProgressNextStage(_("Writing controller configuration"));
    if (modified_hw)
	WriteISDNConfig("contr");
    sleep(sl);

    if(Abort()) return false;
    // stage 4 in writing current ISDN setup
    ProgressNextStage(_("Writing interface configuration"));
    WriteISDNConfig("net");
    sleep(sl);

    if(Abort()) return false;
    // stage 5 in writing current ISDN setup
    ProgressNextStage(_("Writing firewall settings"));
    Firewall::Write();
    sleep(sl);

    if(Abort()) return false;
    // stage 6 in writing current ISDN setup
    ProgressNextStage(_("Writing providers"));
    if (Provider::Modified())
	Provider::Write();
    sleep(sl);

    if(Abort()) return false;
    // stage 7 in writing current ISDN setup
    ProgressNextStage(_("Running SuSEconfig"));
    SCR::Execute(.target.bash, "/sbin/SuSEconfig --module isdn");
    sleep(sl);

    if(Abort()) return false;

    if (start) {
	// stage 8 in writing current ISDN setup
	ProgressNextStage(_("Load ISDN driver"));
	if (modified_hw) {
	    cmd = sformat("/etc/init.d/isdn start -o all");
	    SCR::Execute(.target.bash, cmd);
	    modified_hw = false;
	}
	sleep(sl);

	if(Abort()) return false;
	// stage 9 in writing current ISDN setup
	ProgressNextStage(_("Setting up network services"));
	EnableNetwork();
	sleep(sl);

	if(Abort()) return false;
	// stage 10 in writing current ISDN setup
	ProgressNextStage(_("Setting up smpppd(8)"));
	EnableSMPPPD();
	sleep(sl);

	if(Abort()) return false;
	// stage 11 in writing current ISDN setup
	ProgressNextStage(_("Load ISDN network"));
	cmd = sformat("/etc/init.d/network start -o type=isdn");
	SCR::Execute(.target.bash, cmd);
	cmd = sformat("/etc/init.d/network start -o type=ippp");
	SCR::Execute(.target.bash, cmd);
	modified_if = false;
	sleep(sl);

	if(Abort()) return false;
	// stage 12 in writing current ISDN setup
	ProgressNextStage(_("Running kinternet"));
	RunKInternet();
	sleep(sl);
    }

    if(Abort()) return false;
    // last stage in writing current ISDN setup
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Test the given card settings
 * @return true on success
 */
global define boolean TestDev(string dev) ``{

    // title for ISDN testing current setup progress screen
    string caption = sformat(_("Testing ISDN configuration %1"), dev);
    string cmd = "";
    string details = "";
    map out = $[];
    integer result = 1;
    integer steps = 5;

    integer sl = 500; //1000;
    sleep(sl);

    Progress::New(caption, " ", steps, [
    // steps for the ISDN testing current setup progress screen
    // step 1/5
	_("Write controller configuration"),
    // step 2/5
	_("Stop ISDN network"),
    // step 3/5
	_("Unload ISDN driver"),
    // step 4/5
	_("Load controller"),
    // step 5/5
	_("Unload controller")
    ], [], "");

    if(Abort()) return false;
    // stage 1 in testing current ISDN setup
    ProgressNextStage(_("Writing controller configuration"));
    WriteOneISDNConfig(dev);
    sleep(sl);

    if(Abort()) return false;
    // stage 2 in testing current ISDN setup
    ProgressNextStage(_("Stop ISDN network"));
    cmd = sformat("/etc/init.d/network stop -o type=isdn");
    out = SCR::Execute(.target.bash_output, cmd);
    details = details + cmd + "\n";
    details = details + lookup(out, "stdout", "");
    details = details + lookup(out, "stderr", "");
    details = details + "\n";
    cmd = sformat("/etc/init.d/network stop -o type=ippp");
    out = SCR::Execute(.target.bash_output, cmd);
    details = details + cmd + "\n";
    details = details + lookup(out, "stdout", "");
    details = details + lookup(out, "stderr", "");
    details = details + "\n";
    sleep(sl);

    if(Abort()) return false;
    // stage 3 in testing current ISDN setup
    ProgressNextStage(_("Unload ISDN driver"));
    cmd = sformat("/etc/init.d/isdn stop");
    out = SCR::Execute(.target.bash_output, cmd);
    details = details + cmd + "\n";
    details = details + lookup(out, "stdout", "");
    details = details + lookup(out, "stderr", "");
    details = details + "\n";
    sleep(sl);

    if(Abort()) return false;
    // stage 4 in testing current ISDN setup
    ProgressNextStage(_("Load controller"));
    cmd = sformat("/etc/init.d/isdn start %1 -o all", dev);
    out = SCR::Execute(.target.bash_output, cmd);
    details = details + cmd + "\n";
    details = details + lookup(out, "stdout", "");
    details = details + lookup(out, "stderr", "");
    details = details + "\n";
    result = lookup(out, "exit", 1);
    sleep(sl);

    if(Abort()) return false;
    // stage 5 in testing current ISDN setup
    ProgressNextStage(_("Unload controller"));
    cmd = sformat("/etc/init.d/isdn stop");
    out = SCR::Execute(.target.bash_output, cmd);
    details = details + cmd + "\n";
    details = details + lookup(out, "stdout", "");
    details = details + lookup(out, "stderr", "");
    details = details + "\n";
    sleep(sl);

    if(Abort()) return false;
    // last stage in testing current ISDN setup
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    display_testresult(result, details);
    operation = `testdev;
    return true;
}

/**
 * default settings of hw device
 *
 * @param map of parameters
 *
 */
global define set_cardparameter(map cfg) ``{
    string ac = cfg["AREACODE"]: global_ac;
    if (ac != "" && global_ac == "")
	global_ac = ac;
    change(cfg, "AREACODE", ac);
    string dp = cfg["DIALPREFIX"]: global_dp;
    if (dp != "" && global_dp == "")
	global_dp = dp;
    if (dp != "")
	change(cfg, "DIALPREFIX", dp);
    string sm = cfg["STARTMODE"]: "onboot";
    if (sm == "hotplug")
        global_sm = "hotplug";
    if (sm == "")
	sm = "onboot";
    change(cfg, "STARTMODE", sm);
}

/**
 * default settings of interface
 *
 * @param map of parameters
 *
 */
global define set_ifparameter(map cfg) ``{
    string sm = cfg["STARTMODE"]: global_sm;
    if (sm != "" && global_sm == "")
        global_sm = sm;
    if (sm == "")
	sm = "onboot";
    change(cfg, "STARTMODE", sm);
    provider_file = cfg["PROVIDER"]: "";
}

/**
 * copy detected hw settings to current item
 *
 * @param map of detected hw settings
 *
 */
global define set_hwparameter(map hw) ``{
    // Fixme parameter lookup for ISA hardware
    change(hw_device, "PARA_TYPE", sformat("%1", get_i4ltype(hw)));
    change(hw_device, "PARA_SUBTYPE", sformat("%1", get_i4lsubtype(hw)));
    change(hw_device, "NAME", sformat("%1", lookup(hw, "name", "unknown")));
    change(hw_device, "UNIQUE", lookup(hw, "unique", ""));
}

/**
 * Select the given hardware item or clean up structures
 * @param which item to be chosen
 */
// FIXME: -> routines/hardware.ycp (?)
global define void SelectHW(integer which) ``{
    map sel = $[];

    if(which != nil)
	sel = select(Hardware, which, $[]);

    if(which > size(Hardware) || which < 0)
	y2error("Item not found in Hardware: %1 (%2)", which, size(Hardware));

    type = "contr";
    device = select(GetFreeDevices(type ,1), 0, -1);
    hw_device = $[];
    set_cardparameter(hw_device);
    set_hwparameter(sel);
    operation = `add;
}

/*
 * selects next free cfg-contr<N>
 * and initialisize all cfg-contr<N> values
 * @return true if a free cfg-contr<N> was found
 */
global define boolean Add() ``{
    type = "contr";
    device = select(GetFreeDevices(type, 1), 0, -1);
    if (device<0)
        return false;
    hw_device = $[];
    set_cardparameter(hw_device);
    operation = `add;
    return true;
}

/*
 * selects cfg-<dev> for edit
 * @param  string dev device to edit
 * @return true if cfg-<dev> was found
 */
global define boolean Edit(string dev) ``{
    string typ = device_type(dev);
    integer num = device_num(dev);
    string n = sformat("%1",num);

    map typemap = lookup(Devices, typ, $[]);
    if(!haskey(typemap, n)) {
	y2error("Key not found: %1", dev);
	return false;
    }
    hw_device = lookup(typemap, n, $[]);

    y2debug("Hardware: %1", Hardware);

    device = num;
    type = typ;
    set_cardparameter(hw_device);
    y2debug("devmap=%1", hw_device);
    operation = `edit;
    return true;
}

/*
 * selects cfg-<item> for delete
 * @param  string item item to delete
 * @return true if cfg-<delete> was found
 */
global define boolean Delete(string item) ``{
    operation = nil;
    string typ = device_type(item);
    integer num = device_num(item);

    map typemap = lookup(Devices, typ, $[]);
    if(!haskey(typemap, sformat("%1",num))) {
	y2error("Key not found: %1", item);
	return false;
    }

    type = typ;
    device = num;
    operation = `delete;
    return true;
}

/*
 * selects next free cfg-net<N>
 * and initialisize all cfg-net<N> values
 * @param proto "syncppp" or "rawip"
 * @return true if a free cfg-net<N> was found
 */
global define boolean AddIf(string proto) ``{
    type = "net";
    device = select(GetFreeDevices(type, 1), 0, -1);
    if (device<0)
        return false;
    interface = $[];
    set_ifparameter(interface);
    change(interface, "PROTOCOL", proto);
    operation = `addif;
    return true;
}

/*
 * selects interface cfg-<item> for edit
 * @param  string item interface to edit
 * @return true if cfg-<item> was found
 */
global define boolean EditIf(string item) ``{
    string typ = device_type(item);
    integer num = device_num(item);
    string n = sformat("%1",num);

    map typemap = lookup(Devices, typ, $[]);
    if(!haskey(typemap, n)) {
	y2error("Key not found: %1", item);
	return false;
    }
    interface = lookup(typemap, n, $[]);
    /* interface settings */
    set_ifparameter(interface);
    device = num;
    type = typ;
    operation = `editif;
    return true;
}

/*
 * selects interface cfg-<item>
 * @param  string item interface to select
 * @return true if cfg-<item> was found
 */
global define boolean SelIf(string item) ``{
    string typ = device_type(item);
    integer num = device_num(item);
    string n = sformat("%1",num);

    map typemap = lookup(Devices, typ, $[]);
    if(!haskey(typemap, n)) {
	y2error("Key not found: %1", item);
	return false;
    }
    interface = lookup(typemap, n, $[]);
    set_ifparameter(interface);
    device = num;
    type = typ;
    return true;
}

/*
 * commit changes of the current item
 * defined by type device
 * @return true if the current item was found
 */
global define boolean Commit() ``{
    y2debug("Commit(%1) dev:%2%3",operation,type,device);
	y2debug("skip %1", skip);
    string n = sformat("%1", device);

    if (operation == nil)
	return true;

    if (skip && operation != `add && operation != `edit && operation != `delete)
    {
        skip = false;
        return true;
    }
    if (operation == `edit || operation == `editif || operation == `addproc) {

	map typemap = lookup(Devices, type, $[]);
	y2debug("typemap %1", typemap);
	if(!haskey(typemap, n)) {
	    y2error("Key not found: %1", device);
	    return false;
	}

    }
    if (operation == `add || operation == `edit) {

	string ac = hw_device["AREACODE"]:"";
	if (ac != "")
	    global_ac = ac;
	string dp = hw_device["DIALPREFIX"]:"";
	global_dp = dp;
	string sm = hw_device["STARTMODE"]: "";
	if (sm == "hotplug")
	    global_sm = "hotplug";
	if (sm == "manual" && global_sm == "onboot")
	    global_sm = "manual";

	ChangeDevice(type, device, hw_device, operation == `add);
	modified_hw = true;

    } else if (operation == `addif || operation == `editif) {

	change(interface, "PROVIDER", provider_file);
	if(operation == `addif)
	    Provider::Commit();
	ChangeDevice(type, device, interface, operation == `addif);
	modified_if = true;

    } else if(operation == `addprov || operation == `editprov) {

	Provider::Commit();
	change(interface, "PROVIDER", provider_file);
	ChangeDevice(type, device, interface, operation == `addprov);
	modified_if = true;

    } else if(operation == `testdev) {

        y2debug("op testdev");

    } else if(operation == `delete) {

	DeleteDevice(type, device);

	if (type == "contr")
	    modified_hw = true;
	else
	    modified_if = true;

    } else {
	y2error("Unknown operation: %1", operation);
	return false;
    }

    operation = nil;
    return true;
}

/**
 */
global define boolean Import(map settings) ``{
    Provider::Import(lookup(settings, "_PROVIDERS", $[]));
    Devices = add(settings, "_PROVIDERS", nil);
}

/**
 */
global define map Export() ``{
    map PROVIDERS = Provider::Export();
    return add(Devices, "_PROVIDERS", PROVIDERS);
}

/**
 * Build a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global define list Summary(boolean split) ``{
    return BuildSummary(split);
}

/**
 */
global define list OverviewDev() ``{
    return filter(`i, BuildOverview(), ``(issubstring(select(select(i,0,nil),0,""),"contr")));
    //return BuildOverview("contr");
}

global define list OverviewIf() ``{
    return filter(`i, BuildOverview(), ``(issubstring(select(select(i,0,nil),0,""),"net")));
    //return BuildOverview("net");
}

/**
 * Count of valid interface entries
 * @return count
 */
global define integer CountIF() ``{
    map typemap = lookup(Devices, "net", $[]);

    return size(typemap);
}

/**
 * If not allready done set a valid interface
 * @return true  if the selection was successful
 *         false if here aren't any interfaces
 */
global define boolean PrepareInterface() ``{
    if ((device > -1) && (type == "net"))
	return true;
    map typemap = lookup(Devices, "net", $[]);
    if (0 == size(typemap))
	return false;
    string id = "";
    maplist(`num, `devmap, typemap, ``{
	id = sformat("net%1", num);
    });
    return SelIf(id);
}

/**
 * Displays a popup to select one interface to be the
 * current interface
 * @param auto if true and only one interface exist
 *             take it without a extra dialog
 * @return true  if the selection war successful
 *         false if here aren't any interfaces
 */
global define boolean SelectInterface(boolean auto) ``{

    map typemap = lookup(Devices, "net", $[]);
    string id = "";
    integer s = size(typemap);

    y2debug("device = %1", device);
    y2debug("typemap = %1", typemap);

    if (s == 0)
	return(false);
    if (auto && (s == 1)) {
	maplist(`num, `devmap, typemap, ``{
	    id = sformat("net%1", num);
	});
	return SelIf(id);
    }

    list ifl = maplist(`num, `devmap, typemap, ``{
	string p = lookup(devmap, "PROTOCOL", "");
	string devid = sformat("net%1", num);
	string devnam = "";
	if (p == "syncppp")
	    devnam = sformat("ippp%1", num);
	else if (p == "rawip")
	    devnam = sformat("isdn%1", num);
	else
	    devnam = sformat("unknown%1", num);
	return `item(`id(devid), devnam, (tointeger(num) == device));
    });
    y2debug("ifl=%1", ifl);
    // popup title to select a interface for an edit/delete operation
    id = select_fromlist_popup(_("&Select Interface"), ifl);
    return SelIf(id);
};

global define string GetInterface4Provider(string prov) ``{
    string ifn = "";
    map typemap = lookup(Devices, "net", $[]);

    maplist(`num, `devmap, typemap, ``{
	if (prov == lookup(devmap, "PROVIDER", "")) {
	    if ("syncppp" == lookup(devmap, "PROTOCOL", ""))
		ifn = sformat("ippp%1",num);
	    else
		ifn = sformat("isdn%1",num);
	}
	return false;
    });
    return ifn;
}
/* EOF */
}
