/**
 * File:	modules/Routing.ycp
 * Package:	Network configuration
 * Summary:	Routing data
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 */

{

module "Routing";
textdomain "network";

import "Detection";
import "NetworkDevices";
import "Map";

/**
 * All routes
 */
global list<map> Routes = [];

/**
 * Enable IP forwarding
 */
global boolean Forward = false;

/**
 * List of available devices
 */
list devices = [];

/**
 * All routes read at the start
 */
list Orig_Routes = nil;
boolean Orig_Forward = nil;

/**
 * "routes" file location
 */
string routes_file = "/etc/sysconfig/network/routes";

/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() {
    boolean ret = (Routes != Orig_Routes || Forward != Orig_Forward);
    y2debug("ret=%1", ret);
    return ret;
}

/**
 * Read routing settings
 * @return true if success
 */
global define boolean Read() {

    /* read route.conf */
    if(SCR::Read(.target.size, routes_file) > 0)
	Routes = (list<map>) SCR::Read(.routes);
    else
	Routes = [];

    /* enabled IP forwarding */
    if(SCR::Read(.sysconfig.sysctl.IP_FORWARD) == "yes")
	Forward = true;

    y2debug("Routes=%1", Routes);
    y2debug("Forward=%1", Forward);

    /* save routes to check for changes later */
    Orig_Routes = (list) eval(Routes);
    Orig_Forward = (boolean) eval(Forward);

    /* read available devices */
    NetworkDevices::Read();
    devices = NetworkDevices::List("");

    if(Routes == []) {
	string gw = Detection::result["GATEWAY"]:"";
	if(gw != "" && gw != nil)
	    Routes = [ $[
		"destination"       : "default",
		"gateway"           : gw,
		"netmask"           : "-",
		"device"            : "-"
	    ] ];
    }

    return true;
}

/**
 * Write routing settings and apply changes
 * @return true if success
 */
global define boolean Write() {

    y2milestone("Writing configuration");
    if(!Modified()) {
	y2milestone("No changes to routing -> nothing to write");
	return true;
    }

    if(Forward) {
	SCR::Write(.sysconfig.sysctl.IP_FORWARD, "yes");
	SCR::Execute(.target.bash, "echo 1 > /proc/sys/net/ipv4/ip_forward");
    }
    else {
	SCR::Write(.sysconfig.sysctl.IP_FORWARD, "no");
	SCR::Execute(.target.bash, "echo 0 > /proc/sys/net/ipv4/ip_forward");
    }

    /* at first stop the running routes */
    // FIXME SCR::Execute(.target.bash, "/etc/init.d/route stop");

    /* create if not exists, otherwise backup */
    if(SCR::Read(.target.size, routes_file) < 0)
	SCR::Write(.target.string, routes_file, "");
    else
	SCR::Execute(.target.bash, "/bin/cp "+routes_file+" "+routes_file+".YaST2save");

    any ret = false;
    if(Routes == [])
	/* workaround bug [#4476] */
	ret = SCR::Write(.target.string, routes_file, "");
    else
	/* update the routes config */
	ret = SCR::Write(.routes, Routes);

    /* and finally set up the new routes */
    // FIXME SCR::Execute(.target.bash, "/etc/init.d/route start");

    return ret == true;
}


/**
 * Get all the Routing configuration from a map.
 * When called by routing_auto (preparing autoinstallation data)
 * the map may be empty.
 * @param settings autoinstallation settings
 * @return true if success
 */
global define boolean Import(map settings) {
    if(size(settings) == 0)
	return true;

    Routes = (list<map>) eval(settings["routes"]:[]);
    Forward = settings["ip_forward"]:false;

    Orig_Routes = nil;
    Orig_Forward = nil;

    return true;
}

/**
 * Dump the Routing settings to a map, for autoinstallation use.
 * @return autoinstallation settings
 */
global define map Export() {
    map<string, any> exproute = $[];
    if (size(eval(Routes))> 0)
        exproute["routes"] = eval(Routes);
    exproute["ip_forward"] = Forward;
    return exproute;
}

/**
 * Create routing text summary
 * @return summary text
 */
global define string Summary() {

    string summary = "";

    if(Forward == true)
	/* Summary text */
	summary = summary + _("IP Forwarding: on");
    else
	/* Summary text */
	summary = summary + _("IP Forwarding: off");

    if(Routes != []) {
	/* Summary text */
	summary = summary + "<p>" + sformat(_("Routes: %1"), sformat("<br>%1", Routes));
    }

    return summary;
}

/**
 * Get the current devices list
 * @return devices list
 */
global define list GetDevices() {
    return devices;
}

/**
 * Get the default gateway
 * @return gateway
 */
global define string GetGateway() {
    string defgw = "";
    maplist(map r, Routes, {
	if(r["destination"]:"" == "default")
	    defgw = r["gateway"]:"";
    });
    return defgw;
}

/**
 * Set the available devices list (for expert routing dialog)
 * @param devs new devices list
 * @return true if success
 */
global define boolean SetDevices(list devs) {
    if(devs == nil) {
	devices = [];
	return false;
    }
    devices = devs;
    return true;
}

/* EOF */
}
