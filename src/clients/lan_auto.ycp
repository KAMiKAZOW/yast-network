/**
 * File:	clients/lan_proposal.ycp
 * Package:	Network configuration
 * Summary:	Lan configuration proposal
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 */

{

textdomain "network";

y2milestone("----------------------------------------");
y2milestone("Lan autoinst client started");

import "Lan";
import "Progress";
import "Mode";
include "network/lan/wizards.ycp";
include "network/install.ycp";

/**
 * Convert data from autoyast to structure used by module.
 * @param input autoyast settings
 * @return native network settings
 */
define map FromAY(map input) ``{
	// Used netdevice during installation
	map InstallInf = $[];
	ReadInstallInf();
	string netdevice = InstallInf["netdevice"]:"eth0";

    list upcase = [
		   "bootproto",
		   "mtu",
		   "broadcast",
		   "ipaddr",
		   "netmask",
		   "network",
		   "startmode",
		   "dhclient_set_down_link",
		   "wireless",
		   "wireless_mode",
		   "wireless_essid",
		   "wireless_nwid",
		   "wireless_key",
		   "wireless_nick",
		   "remote_ipaddr"
    ];

    map interfaces = listmap(map interface, input["interfaces"]:[], ``{
	map new_interface = $[];
	foreach(string k, string v, interface, ``{
	    if (contains(upcase, k)) {
		new_interface[toupper(k)] = v;
	    }
	    else if (v != "" && k!="device") {
		new_interface[k] = v;
	    }
	});
	return([interface["device"]:netdevice,new_interface]);
    });

    map devices = $[];
    foreach(string device, map if_data, interfaces, ``{

	integer pos = findfirstof( device, "0123456789");
	string strtok =  substring(device, 0, pos);
	string inttok = substring(device, pos);

	map device = devices[strtok]:$[];
	device=add(device, inttok, if_data);
	devices[strtok] = device;

    });
    map native_modules = $[];

    if (size(input["modules"]:[]) > 0) {
	map tmp_modules = listmap(map mod, input["modules"]:[], ``{
	    string dev = mod["device"]:"";
	    return([dev, mod["module"]:""]);
	});
	native_modules["alias"] = tmp_modules;
	tmp_modules = listmap(map mod, input["modules"]:[], ``{
        string options = mod["options"]:"";
        string module_name = mod["module"]:"";
		return([module_name, options]);
    });
	native_modules["options"] = tmp_modules;

    }
    else if (size(input["modules"]:[]) == 0 && Mode::autoinst)
    {
	import "Arch";
	if(!Arch::s390) Lan::ReadHardware("netcard");
	list HW = Lan::GetHardware();
	map alias = $[];
	map options = $[];
	devices = mapmap(string type, map devsmap, devices, ``{
	    list HW_type = filter(`dev, HW, ``(dev["type"]:"" == type ));

	    y2debug("hw from type %1 = %2", type, HW_type);

	    map newmap = mapmap(string num, map devmap, devsmap, ``{

		devmap = add(devmap, "UNIQUE", HW_type[ tointeger(num) ,"unique"]:"" );
		string device = sformat ("%1%2", type, num );
		string modname = HW_type[ tointeger(num) ,"module"]:"";
		alias[device] = modname;
		// map tmpopt = $[modname: HW_type[ tointeger(num) ,"options"]:""];
		options[modname] = HW_type[ tointeger(num) ,"options"]:"";

		return([num, devmap]);

	    });
	    return ([ type, newmap ] );
	});
	native_modules["alias"] = alias;
	native_modules["options"] = options;

    }


    input["devices"] = devices;
    input["modules"] = native_modules;
	map dhcpopts =  input["dhcp_options"]:$[];

	map dns = input["dns"]:$[];
	map dhcp = $[];

	if (haskey(dns, "dhcp_hostname"))
        dhcp["DHCLIENT_SET_HOSTNAME"] = dns["dhcp_hostname"]:false;
	if (haskey(dns, "dhcp_resolv"))
		dhcp["DHCLIENT_MODIFY_RESOLV_CONF"] = dns["dhcp_resolv"]:false;

	if (haskey(dhcpopts, "dhclient_client_id"))
	    dhcp["DHCLIENT_CLIENT_ID"] = dhcpopts["dhclient_client_id"]:"";
    if (haskey(dhcpopts, "dhclient_additional_options"))
	    dhcp["DHCLIENT_ADDITIONAL_OPTIONS"] = dhcpopts["dhclient_additional_options"]:"";
    if (haskey(dhcpopts, "dhclient_hostname_option"))
	    dhcp["DHCLIENT_HOSTNAME_OPTION"] = dhcpopts["dhclient_hostname_option"]:"AUTO";

	map config = $[];
	config["dhcp"] = dhcp;
	input["config"] = config;

    return input;
}

/**
 * Convert data from native network to autoyast for XML
 * @param settings native network settings
 * @return autoyast network settings
 */
define map ToAY (map settings) ``{
    list interfaces = [];
	list discard = ["UNIQUE"];
    foreach(string device, map devsmap, settings["devices"]:$[], ``{
	foreach(string num, map devmap, devsmap, ``{
	    map newmap = $[];
	    foreach(string key, string val, devmap, ``{
			y2milestone("Adding: %1=%2", key, val);
			if ( size(val) > 0 && ( !contains(discard, key) && !contains(discard, tolower(key))))
				change(newmap, tolower(key), val);
	    });
	    change(newmap, "device", device + num);
	    change(interfaces, newmap);
	});
    });

	// Modules

    list modules = [];
    foreach(string device, string mod, settings["modules", "alias"]:$[], ``{
	    map newmap = $[];
	    newmap["device"] =  device;
	    newmap["module"] =  mod;
		newmap["options"] = settings["modules", "options", mod]:"";
	    change(modules, newmap);
    });

	map config = settings["config"]:$[];
	map dhcp = config["dhcp"]:$[];
	boolean dhcp_resolv = dhcp["DHCLIENT_MODIFY_RESOLV_CONF"]:false;
	boolean dhcp_hostname = dhcp["DHCLIENT_SET_HOSTNAME"]:false;
	map dns = settings["dns"]:$[];
	dns["dhcp_hostname"] = dhcp_hostname;
	dns["dhcp_resolv"] = dhcp_resolv;
	map dhcpopts = $[];
	if (haskey(dhcp, "DHCLIENT_HOSTNAME_OPTION"))
		dhcpopts["dhclient_hostname_option"] = dhcp["DHCLIENT_HOSTNAME_OPTION"]:"AUTO";
	if (haskey(dhcp, "DHCLIENT_ADDITIONAL_OPTIONS"))
        dhcpopts["dhclient_additional_options"] = dhcp["DHCLIENT_ADDITIONAL_OPTIONS"]:"";
	if (haskey(dhcp, "DHCLIENT_CLIENT_ID"))
        dhcpopts["dhclient_client_id"] = dhcp["DHCLIENT_CLIENT_ID"]:"";


	map ret = $[];
	if (size(modules) > 0 )
		ret["modules"] = modules;
	if (size(dns) > 0 )
        ret["dns"] = dns;
    if (size(dhcpopts) > 0 )
        ret["dhcp_options"] = dhcpopts;
    if (size(settings["routing"]:$[]) > 0 )
        ret["routing"] = settings["routing"]:$[];
    if (size(interfaces) > 0 )
        ret["interfaces"] = interfaces;

	return (ret);

}


any ret = nil;
string func = "";
map param = $[];

/* Check arguments */
if(size(WFM::Args()) > 0 && is(WFM::Args(0), string)) {
    func = (string) WFM::Args(0);
    if(size(Args()) > 1 && is(WFM::Args(1), map))
	param = (map) WFM::Args(1);
}
y2debug("func=%1", func);
y2debug("param=%1", param);


if(func == "Summary") {
    ret = select(Lan::Summary(false),0, "");
}
else if (func == "Reset") {
    Lan::Import($[]);
    ret = $[];
}
else if (func == "Change") {
    ret = LanAutoSequence();
}
else if(func == "Import") {
    map autoyast = FromAY(param);
    ret = Lan::Import(autoyast);
}
else if(func == "Read") {
    Progress::off();
    ret = Lan::Read();
    Progress::on();
}
else if (func == "Packages") {
    ret = $[];
}
else if (func == "Export") {
    map settings = Lan::Export();
    map autoyast = ToAY(settings);
    ret = autoyast;
}
else if (func == "Write") {
    Progress::off();
    Lan::write_only = true;
    ret = Lan::Write();
    Progress::on();
}
/* unknown function */
else {
    y2error("unknown function: %1", func);
    ret =  false;
}


y2debug("ret=%1", ret);
y2milestone("Lan auto finished");
y2milestone("----------------------------------------");

return ret;

/* EOF */
}
