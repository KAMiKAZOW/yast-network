/**
 * File:	clients/lan_proposal.ycp
 * Package:	Network configuration
 * Summary:	Lan configuration proposal
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 */

{

textdomain "network";

y2milestone("----------------------------------------");
y2milestone("Lan autoinst client started");

import "Lan";
import "Progress";
import "Arch";
import "Mode";
include "network/lan/wizards.ycp";

any ret = nil;
string func = "";
map param = $[];

/* Check arguments */
if(size(WFM::Args()) > 0 && is(WFM::Args(0), string))
{
    func = (string) WFM::Args(0);
    if(size(WFM::Args()) > 1 && is(WFM::Args(1), map))
	param = (map) WFM::Args(1);
}
y2debug("func=%1", func);
y2debug("param=%1", param);
Mode::test = false;

if (Mode::test)
{
    Mode::autoinst = true;
    param = $["dns":$["dhcp_hostname":false, "dhcp_resolv":false],
    "interfaces":[$["bootproto":"dhcp", "device":"eth-id-00:0e:0c:08:36:7a",
    "startmode":"onboot"]], "routing":$["ip_forward":false]];
    func = "Import";
}

/**
 * Convert data from autoyast to structure used by module.
 * @param input autoyast settings
 * @return native network settings
 */
define map FromAY(map input) {
    // Used netdevice during installation
    map InstallInf = $[];
    include "network/install.ycp";
    ReadInstallInf();
    string netdevice = InstallInf["netdevice"]:"eth0";

    list upcase = [
		   "bootproto",
		   "mtu",
		   "broadcast",
		   "ipaddr",
		   "netmask",
		   "network",
		   "startmode",
		   "dhclient_set_down_link",
		   "wireless",
		   "wireless_mode",
		   "wireless_essid",
		   "wireless_nwid",
		   "wireless_key",
		   "wireless_nick",
		   "remote_ipaddr"
    ];

    integer dn = 0;
    list<map> hw = [];
    if (Mode::autoinst)
        hw = Lan::PrepareForAutoinst();
    map devicemapping = $[];
    map<string,map> interfaces = listmap(map<string,string> interface,
            input["interfaces"]:[],
    {
	map new_interface = $[];
	foreach(string k, string v, interface, {
	    if (contains(upcase, k)) {
		new_interface[toupper(k)] = v;
	    }
	    else if (v != "" && k!="device") {
		new_interface[k] = v;
	    }
	});
        string configured_device = interface["device"]:"";
        string device = "";
        boolean configured = false;
        if ( Mode::autoinst )
        {
            list devid = splitstring(configured_device, "-");
            if (size(devid)> 0 )
            {
                string mac = devid[2]:"";
                list avail = filter(map conf, hw, ``(conf["mac"]:"" == mac));
                if (size(avail) > 0) {
                    device = devid[1]:"" + "-" +  devid[2]:"";
                    new_interface["_type"] = avail[0, "type"]:"";
                    configured = true;
                }
            }
            if (!configured) {
                Lan::SelectHW(dn);
                device = Lan::device;
                new_interface["_type"] = hw[dn, "type"]:"";
            }
            devicemapping[configured_device] = device;
        }
        else
        {
            device = configured_device;
        }
        dn = dn + 1;
	return $[ device : new_interface ];
    });

    map devices = $[];

    foreach(string devname, map if_data, interfaces, {

        if (!Mode::autoinst)
        {
	    integer pos = findfirstof( devname, "0123456789");
	    string strtok =  substring(devname, 0, pos);
	    string inttok = substring(devname, pos);
	    map d = devices[strtok]:$[];
	    d=add(d, inttok, if_data);
	    devices[strtok] = d;
        } else {
            string t = if_data["_type"]:"";
	    map d = devices[t]:$[];
	    d=add(d, devname, if_data);
            devices[t] = d;
        }

    });
    map hwcfg = $[];

    if (size(input["modules"]:[]) > 0)
    {
        // "hwcfg":$["bus-pci-0000:02:05.0":$["MODULE":"sk98lin",
        // "MODULE_OPTIONS":"", "STARTMODE":"auto"]]
	hwcfg = listmap(map mod, input["modules"]:[], {
            string options = mod["options"]:"";
            string module_name = mod["module"]:"";
            string start_mode= mod["startmode"]:"auto";
            string device_name= mod["device"]:"";

            map module_data = $["MODULE":module_name,
                                "MODULE_OPTIONS":options,
                                "STARTMODE":start_mode
                                ];
            if (Mode::autoinst)
            {
                device_name = devicemapping[device_name]:"";
            }
	    return $[device_name : module_data];
        });
    }
    if ( Mode::autoinst)
    {
	map alias = $[];
	map options = $[];
        integer n = 0;
	devices = mapmap(string type, map devsmap, (map<string,map>) devices, {
	    list HW_type = filter(map dev, hw, {
		return dev["type"]:"" == type;
	    });

	    y2milestone("hw from type %1 = %2", type, HW_type);

	    map newmap = mapmap(string device_id, map devmap, (map<string,map>) devsmap, {

		devmap["UNIQUE"] = HW_type[n, "unique"]:"";
		string modname = HW_type[n, "module"]:"";
		string options = HW_type[n, "options"]:"";
                Lan::SelectHW(dn);
                string device = Lan::device;
                if (!haskey(hwcfg, device))
                {
                    hwcfg=add(hwcfg, device, $["MODULE":modname,
                        "MODULE_OPTIONS":options,
                        "STARTMODE":"auto"]);
                }

		return $[device_id : devmap];

	    });
            n = n + 1;
	    return $[type : newmap];
	});
    }


    input["devices"] = devices;
    input["hwcfg"] = hwcfg;
    map dhcpopts =  input["dhcp_options"]:$[];

    map dns = input["dns"]:$[];
    map dhcp = $[];

    if (haskey(dns, "dhcp_hostname"))
        dhcp["DHCLIENT_SET_HOSTNAME"] = dns["dhcp_hostname"]:false;
    if (haskey(dns, "dhcp_resolv"))
        dhcp["DHCLIENT_MODIFY_RESOLV_CONF"] = dns["dhcp_resolv"]:false;

    if (haskey(dhcpopts, "dhclient_client_id"))
        dhcp["DHCLIENT_CLIENT_ID"] = dhcpopts["dhclient_client_id"]:"";
    if (haskey(dhcpopts, "dhclient_additional_options"))
        dhcp["DHCLIENT_ADDITIONAL_OPTIONS"] = dhcpopts["dhclient_additional_options"]:"";
    if (haskey(dhcpopts, "dhclient_hostname_option"))
        dhcp["DHCLIENT_HOSTNAME_OPTION"] = dhcpopts["dhclient_hostname_option"]:"AUTO";

    map config = $[];
    config["dhcp"] = dhcp;
    input["config"] = config;

    y2milestone("input=%1", input);
    return input;
}

/**
 * Convert data from native network to autoyast for XML
 * @param map settings native network settings
 * @return map autoyast network settings
 */
define map ToAY (map settings) {
    list interfaces = [];
    list discard = ["UNIQUE", "_nm_name"];
    foreach(string device, map devsmap, settings["devices"]:$[], {
            foreach(string num, map devmap, (map<string,map>) devsmap, {
                map<string, any> newmap = $[];
                foreach(string key, any val, (map<string,any>) devmap, {
                    y2milestone("Adding: %1=%2", key, val);
                    if (key!="_aliases")
                    {
                    if ( size((string)val) > 0 && ( !contains(discard, key) && !contains(discard, tolower(key))))
                    newmap[tolower(key)] = (string)val;
                    }
                    else
                    {
                    // FIXME: handle aliases
                    y2debug("val: %1", val);
                    }
                    });
                if (deletechars(num, "0123456789")
                        == "")
                    newmap["device"] = device + num;
                else
                    newmap["device"] = device + "-" + num;
                interfaces = add(interfaces, newmap);
                });
            });

    // Modules

    list modules = [];
    foreach(string device, map mod, settings["hwcfg"]:$[], {
            map newmap = $[];
            newmap["device"] =  device;
            newmap["module"] =  mod["MODULE"]:"";
            newmap["options"] = mod["MODULE_OPTIONS"]:"";
            modules = add(modules, newmap);
            });

    map config = settings["config"]:$[];
    map dhcp = config["dhcp"]:$[];
    boolean dhcp_resolv = dhcp["DHCLIENT_MODIFY_RESOLV_CONF"]:false;
    boolean dhcp_hostname = dhcp["DHCLIENT_SET_HOSTNAME"]:false;
    map dns = settings["dns"]:$[];
    dns["dhcp_hostname"] = dhcp_hostname;
    dns["dhcp_resolv"] = dhcp_resolv;
    map dhcpopts = $[];
    if (haskey(dhcp, "DHCLIENT_HOSTNAME_OPTION"))
        dhcpopts["dhclient_hostname_option"] = dhcp["DHCLIENT_HOSTNAME_OPTION"]:"AUTO";
    if (haskey(dhcp, "DHCLIENT_ADDITIONAL_OPTIONS"))
        dhcpopts["dhclient_additional_options"] = dhcp["DHCLIENT_ADDITIONAL_OPTIONS"]:"";
    if (haskey(dhcp, "DHCLIENT_CLIENT_ID"))
        dhcpopts["dhclient_client_id"] = dhcp["DHCLIENT_CLIENT_ID"]:"";


    map ret = $[];
    if (size(modules) > 0 )
        ret["modules"] = modules;
    if (size(dns) > 0 )
        ret["dns"] = dns;
    if (size(dhcpopts) > 0 )
        ret["dhcp_options"] = dhcpopts;
    if (size(settings["routing"]:$[]) > 0 )
        ret["routing"] = settings["routing"]:$[];
    if (size(interfaces) > 0 )
        ret["interfaces"] = interfaces;

    return (ret);

}



if(func == "Summary") {
    ret = select(Lan::Summary(false),0, "");
}
else if (func == "Reset") {
    Lan::Import($[]);
    ret = $[];
}
else if (func == "Change") {
    ret = LanAutoSequence();
}
else if(func == "Import") {
    map autoyast = FromAY(param);
    ret = Lan::Import(autoyast);
}
else if(func == "Read") {
    Progress::off();
    ret = Lan::Read();
    Progress::on();
}
else if (func == "Packages") {
    ret = $[];
}
else if (func == "Export") {
    map settings = Lan::Export();
    y2debug("settings: %1", settings);
    map autoyast = ToAY(settings);
    ret = autoyast;
}
else if (func == "Write") {
    Progress::off();
    ret = Lan::WriteOnly();
    Progress::on();
}
/* unknown function */
else {
    y2error("unknown function: %1", func);
    ret =  false;
}


y2debug("ret=%1", ret);
y2milestone("Lan auto finished");
y2milestone("----------------------------------------");

return ret;

/* EOF */
}
