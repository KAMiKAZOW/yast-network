/**
 * File:	include/network/services/dns.ycp
 * Package:	Network configuration
 * Summary:	Hostname and DNS setup dialog
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 */

{

textdomain "network";

import "Arch";
import "DNS";
import "Hostname";
import "IP";
import "Label";
import "Lan";
import "NetworkConfig";
import "Popup";
import "Wizard";

include "network/routines.ycp";

/**
 * If there's running a process modifying resolv.conf,
 * present a wanrning popup and return the result.
 * @return true if resolv.conf should be modified
 * (ie. no process running, or user decided to do so)
 */
define boolean ModifyResolvConfPopup() {

    string process = DNS::resolv_conf_process;
    if(process == nil || process == "") return true;

    /* Warning popup text 1/2 */
    string text = _("<p>The resolver configuration file (/etc/resolv.conf)
has been temporarily modified by %1. You have two options:</p>") +

    /* Warning popup text 2/2 */
    _("<ol>
<li>Modify the current (changed) version of the file.</li>
<li>Press 'Accept' now and continue editing other (nonresolver) data. You
could return to this dialog later when the above service has terminated.</li>
</ol>
");

    /* has been modified by "unknown process" */
    text = sformat(text, size(process) > 1 ? process : _("unknown process"));

    UI::OpenDialog(`opt(`decorated), `VBox(
	`HSpacing(60),
	`HBox(
	    `VSpacing(8),
	    `RichText(text)
	),
	`HBox(
	    /* PushButton label */
	    `PushButton(`id(`accept), `opt(`default), _("&Accept")),
	    `HSpacing(2),
	    /* PushButton label */
	    `PushButton(`id(`modify), _("&Modify"))
	)
    ));

    any ret = UI::UserInput();
    UI::CloseDialog();

    DNS::resolv_conf_force = (ret == `modify);
    y2milestone ("resolv.conf modified by: %1, force: %2",
		 process, DNS::resolv_conf_force);
    return DNS::resolv_conf_force;
}

/**
 * @return initial settings for this dialog in one map, from DNS::
 */
define map InitSettings () {
    return $[
	"hostname": DNS::hostname,
	"domain": DNS::domain,
	"nameservers": DNS::nameservers, // 3?
	"searchlist": DNS::searchlist,
	"dhcp_hostname": NetworkConfig::DHCP["DHCLIENT_SET_HOSTNAME"]:false,
	"dhcp_resolv": NetworkConfig::DHCP["DHCLIENT_MODIFY_RESOLV_CONF"]:false,
	];
}

/**
 * @param settings map of settings to be stored to DNS::
 */
define void StoreSettings (map settings) {
    DNS::hostname = settings["hostname"]:"";
    DNS::domain = settings["domain"]:"";
    DNS::nameservers = settings["nameservers"]:[];
    DNS::searchlist = settings["searchlist"]:[];
    NetworkConfig::DHCP["DHCLIENT_SET_HOSTNAME"] = settings["dhcp_hostname"]:false;
    NetworkConfig::DHCP["DHCLIENT_MODIFY_RESOLV_CONF"] = settings["dhcp_resolv"]:false;
}

/**
 * @return settings for this dialog, queried from the widgets
 */
define map QueryWidgets () {
    // idea: QueryWidgets - returns a map with the widget values
    string ns1 = tolower((string) UI::QueryWidget(`id(`ns1), `Value));
    string ns2 = tolower((string) UI::QueryWidget(`id(`ns2), `Value));
    string ns3 = tolower((string) UI::QueryWidget(`id(`ns3), `Value));
    list nameservers = filter (string s, [ns1, ns2, ns3], ``(s != ""));

    string searchstring = tolower((string) UI::QueryWidget(`id(`ss), `Value));
    list searchlist = filter (string s, splitstring (searchstring, " ,\n\t"),
			      ``(s != ""));

    map query = $[
	"hostname": UI::QueryWidget (`id (`host), `Value),
	"domain": UI::QueryWidget (`id (`domain), `Value),
	"nameservers": nameservers,
	"searchlist": searchlist,
	"dhcp_hostname": UI::QueryWidget (`id (`dn), `Value),
	"dhcp_resolv": UI::QueryWidget (`id (`dr), `Value),
	];
    return query;
}

/**
 * Apply UI::ChangeWidget to all `ns[123]
 * @param prop widget property
 * @param value property value
 */ 
define void ChangeNsWidgets (symbol prop, any value) {
    UI::ChangeWidget (`id (`ns1), prop, value);
    UI::ChangeWidget (`id (`ns2), prop, value);
    UI::ChangeWidget (`id (`ns3), prop, value);
}

/**
 * Dialog for querying DNS & hostname info
 * @param standalone true if not run from another ycp client
 * @return user input
 */
define any DNSMainDialog(boolean standalone) {

    ScreenName("dns");

    /* DNS dialog caption */
    string caption = _("Host Name and Name Server Configuration");

    /* DNS dialog help 1/5 */
    string help = _("<p>Insert the host name and domain name for your
computer. Name server list and domain search list are optional.</p>") +

	// #91202
	(standalone? "":
	 /* DNS dialog help 1.5/5 */
	 _("<p>Note that the hostname is global--it applies to all
interfaces, not just this one.</p>")) +

    /* DNS dialog help 2/5 */
    _("<p>A name server is a computer that translates host names into
IP addresses. This value must be entered as an <b>IP address</b>
(e.g., 10.10.0.1), not as a host name.</p>") +

    /* DNS dialog help 3/5 */
    _("<p>Search domain is the domain name where host name searching starts.
The primary search domain is usually the same as the <b>domain name</b> of
your computer (e.g., suse.de). There may be additional search domains
(e.g., suse.com). Separate the domains with commas or white space.</p>") +

    /* DNS dialog help 4/5 */
    _("<p>If you are using DHCP to get an IP address, check whether to get
a host name via DHCP or to set name servers and searched domains via DHCP.</p>") +

    /* DNS dialog help 5/5 */
    _("<p>If you plan to use a dial-up Internet connection and have set up your
connection to use dynamic DNS assignment, these values will be temporarily
disabled during the connection.</p>");

    boolean has_dhcp = (Lan::bootproto == "dhcp") || Lan::AnyDHCPDevice();

    map settings = InitSettings ();
    boolean modified = false;
    boolean dhcp_resolv = settings["dhcp_resolv"]:false;

    /* domain search */
    string searchstring = mergestring (settings["searchlist"]:[], "\n");
    // #49094: populate the search list
    if (searchstring == "" && !settings["dhcp_resolv"]:false)
    {
	searchstring = settings["domain"]:"";
    }

    string hnlabel = standalone?
	/* Frame label */
	_("Host Name and Domain Name"):
	/* Frame label, emphasizing that the names are global,
	   not specific to one address */
	_("Host Name and Domain Name (Global)");

    /* DNS dialog contents */
    term contents = `HSquash(`VBox(
	`Frame(hnlabel, `VBox(
	    `HBox(
		`TextEntry(`id(`host), Label::HostName (), settings["hostname"]:""),
		`HSpacing (1),
		/* TextEntry label */
		`TextEntry(`id(`domain), _("&Domain Name"), settings["domain"]:"")
	    ),
	    /* CheckBox label */
	    `Left(`CheckBox(`id(`dn), _("&Change Host Name via DHCP")))
	)),
	`VSpacing(1),
	/* Frame label */
	`Frame(_("Name Servers and Domain Search List"), `VBox(
	`VSquash ( `HBox(
	    `HWeight (1, `VBox(
		/* TextEntry label */
		`TextEntry(`id(`ns1), _("Name Server &1"), settings["nameservers", 0]:""),
		/* TextEntry label */
		`TextEntry(`id(`ns2), _("Name Server &2"), settings["nameservers", 1]:""),
		/* TextEntry label */
		`TextEntry(`id(`ns3), _("Name Server &3"), settings["nameservers", 2]:"")
	    )),
	    `HSpacing (1),
	    `HWeight (1, `VBox(
		/* TextEntry label */
		`MultiLineEdit (`id (`ss), _("Do&main Search"), searchstring)
	    ))
	)),
	/* CheckBox label */
	`Left(`CheckBox(`id(`dr), `opt(`notify), _("&Update Name Servers and Search List via DHCP")))
	))
    ));

    if(standalone == true)
	Wizard::SetContentsButtons(caption, contents, help,
		Label::BackButton(), Label::FinishButton());
    else
	Wizard::SetContentsButtons(caption, contents, help,
		Label::BackButton(), Label::OKButton());

    UI::ChangeWidget(`id(`dn), `Enabled, has_dhcp);
    UI::ChangeWidget(`id(`dr), `Enabled, has_dhcp);
    if (has_dhcp)
    {
	UI::ChangeWidget(`id(`dn), `Value, settings["dhcp_hostname"]:false);
	UI::ChangeWidget(`id(`dr), `Value, settings["dhcp_resolv"]:false);
    }

    UI::ChangeWidget(`id(`host), `ValidChars, Hostname::ValidChars);
    UI::ChangeWidget(`id(`domain), `ValidChars, Hostname::ValidCharsDomain);
    ChangeNsWidgets (`ValidChars, IP::ValidChars);
    UI::ChangeWidget(`id(`ss), `ValidChars, Hostname::ValidCharsFQ); // TODO \n?

    if(has_dhcp)
    {
	ChangeNsWidgets (`Enabled, !dhcp_resolv);
	UI::ChangeWidget(`id(`ss), `Enabled, !dhcp_resolv);
    }

    if(ModifyResolvConfPopup() != true) {
	UI::ChangeWidget(`id(`dr), `Enabled, false);
	ChangeNsWidgets (`Enabled, false);
	UI::ChangeWidget(`id(`ss), `Enabled, false);
    }

    UI::SetFocus (`id (`host));

    any ret = nil;
    while(true) {

	ret = UI::UserInput();
	if (ret == `cancel)
	{
	    ret = `abort;
	}

	/* going to exit: query, check whether modified */
	if (ret == `abort || ret == `next) {
	    map oldsettings = InitSettings ();
	    settings = QueryWidgets ();
	    modified = settings != oldsettings;
	    y2milestone ("olddns: %1", oldsettings);
	    y2milestone ("newdns: %1", settings);
	    y2milestone ("modified: %1", modified);
	}


	/* hostname via dhcp */
	if (ret == `dn) {
	    // Do nothing (the widget doesnt have notify anyway)
	    // In particular do not disable the host and domain name widgets,
	    // setting of FQDN should be possible even if DHCP overrides it.
	    // N#28427, N#63423.
	    continue;
	}
	/* resolv.conf via dhcp */
	else if(ret == `dr) {
	    dhcp_resolv = (boolean) UI::QueryWidget(`id(`dr), `Value);
	    ChangeNsWidgets (`Enabled, !dhcp_resolv);
	    UI::ChangeWidget(`id(`ss), `Enabled, !dhcp_resolv);
	    continue;
	}
	else if(ret == `back) {
	    break;
	}
	else if (ret == `abort)
	{
	    if (ReallyAbortCond (modified))
	    {
		break;
	    }
	    else continue;
	}
	else if(ret == `next) {
	    /* check host name and domain */
	    boolean dhn = has_dhcp && settings["dhcp_hostname"]:false;
	    // If the names are set by dhcp, the user may enter backup values
	    // here - N#28427. That is, host and domain name are optional then.
	    // For static config, they are mandatory.
	    if(!dhn || settings["hostname"]:"" != "") {
		if (!Hostname::Check (settings["hostname"]:"")) {
		    UI::SetFocus(`id(`host));
		    /* Popup::Error text */
		    Popup::Error (_("The host name is invalid.") +
			"\n" + Hostname::ValidHost ());
		    continue;
		}
	    }
	    if(!dhn || settings["domain"]:"" != "") {
		if(!Hostname::CheckDomain (settings["domain"]:"")) {
		    UI::SetFocus(`id(`domain));
		    /* Popup::Error text */
		    Popup::Error (_("The domain name is invalid.") +
			"\n" + Hostname::ValidDomain ());
		    continue;
		}
	    }

	    /* check nameservers */
	    if(settings["nameservers", 0]:"" != "" && !IP::Check(settings["nameservers", 0]:"")) {
		UI::SetFocus(`id(`ns1));
		/* Popup::Error text */
		Popup::Error(_("The primary name server is invalid."));
		continue;
	    }
	    if(settings["nameservers", 1]:"" != "" && !IP::Check(settings["nameservers", 1]:"")) {
		UI::SetFocus(`id(`ns2));
		/* Popup::Error text */
		Popup::Error(_("The secondary name server is invalid."));
		continue;
	    }
	    if(settings["nameservers", 2]:"" != "" && !IP::Check(settings["nameservers", 2]:"")) {
		UI::SetFocus(`id(`ns3));
		/* Popup::Error text */
		Popup::Error(_("The tertiary name server is invalid."));
		continue;
	    }

	    /* check search domains */
	    if (size (settings["searchlist"]:[]) > 6)
	    {
		UI::SetFocus (`id (`ss));
		/* Popup::Error text */
		Popup::Error(sformat (_("The search list can have at most %1 domains."), 6));
		continue;
	    }
	    if (size (mergestring (settings["searchlist"]:[], " ")) > 256)
	    {
		UI::SetFocus (`id (`ss));
		/* Popup::Error text */
		Popup::Error(sformat (_("The search list can have at most %1 characters."), 256));
		continue;
	    }
	    string bad = find (string s, settings["searchlist"]:[], {
		if (! Hostname::CheckDomain (s)) {
		    UI::SetFocus (`id (`ss));
		    /* Popup::Error text */
		    Popup::Error(
			sformat (_("The search domain '%1' is invalid."), s) +
			"\n" + Hostname::ValidDomain ()
			);
		    return true;
		}
		return false;
	    });
	    if (bad != nil)
	    {
		continue;
	    }

	    break;
	}
	else {
	    y2error("unexpected retcode: %1", ret);
	    continue;
	}

    }

    if(ret == `next) {
	if (settings != InitSettings ()) {
	    StoreSettings (settings);
	    /* update modified flag */
	    DNS::modified = true;
	}
	else
	    y2debug("not modified");
    }

    return ret;
}

/* EOF */
}
