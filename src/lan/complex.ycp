/**
 * File:	include/network/lan/dialogs.ycp
 * Package:	Network configuration
 * Summary:	Summary, overview and IO dialogs for network cards config
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 */

{

textdomain "network";

import "CWM";

import "Lan";
import "DNS";
import "Mode";
import "NetworkConfig";
import "NetworkModules";
import "NetworkService";
import "Routing";

import "Wizard";
import "WizardHW";

import "Popup";
import "Label";

import "Product";
import "Package";

include "network/routines.ycp";
include "network/summary.ycp";

/**
 * Return a modification status
 * @return true if data was modified
 */
define boolean Modified() ``{
    return Lan::Modified() || DNS::modified || Routing::Modified() ||
	NetworkConfig::Modified();
}

/**
 * Commit changes to internal structures
 * @return always `next
 */
define symbol Commit() ``{
    Lan::Commit();
    return `next;
}

/**
 * Display finished popup
 * @return dialog result
 */
define symbol FinishDialog() ``{
    return FinishPopup(Modified(), "lan", "", "mail", ["permanent"]);
}

/**
 * Read settings dialog
 * @return `abort if aborted and `next otherwise
 */
define symbol ReadDialog() ``{

    ScreenName("lan-read");

    /* Network cards read dialog help 1/2 */
    string help = _("<p><b><big>Initializing Network Card
Configuration</big></b><br>Please wait...<br></p>
") +

    /* Network cards read dialog help 2/2 */
_("<p><b><big>Aborting the Initialization:</big></b><br>
Safely abort the configuration utility by pressing <B>Abort</B> now.</p>
");

    Wizard::RestoreHelp(help);
    Lan::AbortFunction = ``{return PollAbort();};
    boolean ret = Lan::Read (`cache);

    boolean xenbr = Lan::HaveXenBridge ();
    if (xenbr)
    {
	if (! Popup::ContinueCancel (
		sformat (
		    // continue-cancel popup, #178848
		    // %1 is a (long) path to a README file
_("A Xen network bridge was detected.
Due to the renaming of network interfaces by the bridge script,
network interfaces should not be configured or restarted.
See %1 for details."), "/usr/share/doc/packages/xen/README.SuSE")))
	{
	    ret = false;
	}
    }

    return ret ? `next : `abort;
}

/**
 * Write settings dialog
 * @return `abort if aborted and `next otherwise
 */
define symbol WriteDialog() ``{
    ScreenName("lan-write");

    if(!Modified()) return `next;

    /* Network cards write dialog help 1/2 */
    string help = _("<p><b><big>Saving Network Card
Configuration</big></b><br>Please wait...<br></p>
") +

    /* Network cards write dialog help 2/2 */
_("<p><b><big>Aborting Saving:</big></b><br>
Abort saving by pressing <b>Abort</b>.</p>
");

    Wizard::RestoreHelp(help);
    Lan::AbortFunction = ``{return PollAbort() && ReallyAbort();};
    boolean ret = Lan::Write();
    return ret ? `next : `abort;
}


define void IPv6Init (string key) {
//    boolean enable_ipv6=true;
//    if (FileUtils::Exists("/etc/modprobe.d/ipv6")){
//	if (((map<string, any>)SCR::Execute (.target.bash_output, "grep ipv6 /etc/modprobe.d/ipv6|cut -d# -f1|grep -q ipv6"))["exit"]:0==0) enable_ipv6=false;
//	}

    UI::ChangeWidget (`id (key), `CurrentButton, Lan::ipv6?"enable":"disable");
}

define void IPv6Store (string key, map event) {
 if ((string) UI::QueryWidget (`id (key), `CurrentButton)=="enable") Lan::SetIPv6(true);
	else Lan::SetIPv6(false);
}

/**
 * Initialize the NetworkManager widget
 * @param key id of the widget
 */
define void ManagedInit (string key) {
    string value = NetworkService::IsManaged ()? "managed": "ifup";
    UI::ChangeWidget (`id (key), `CurrentButton, value);
}

/**
 * Store the NetworkManager widget
 * @param key	id of the widget
 * @param event	the event being handled
 */
define void ManagedStore (string key, map event) {
    string value_g = (string) UI::QueryWidget (`id (key), `CurrentButton);
    boolean value = value_g == "managed";
    if (NetworkService::IsManaged () != value)
	Lan::SetModified ();
    NetworkService::SetManaged (value);
}

/**
 * Dialog to choose whether to use NetworkManager or not
 */
define symbol ManagedDialog () {
    map<string, map<string,any> > wd = $[
	"MANAGED": $[
	    "widget": `radio_buttons,
	    // radio button group label, method of setup
	    "label": _("Network Setup Method"),
	    "items": [
		// radio button label
		// the user can control the network with the NetworkManager
		// program
		["managed", _("&User Controlled with NetworkManager")],
		// radio button label
		// ifup is a program name
		["ifup", _("&Traditional Method with ifup")],
		],
	    "opt": [],
	    "help":
	    /* Network setup method help */
	    // NetworkManager and ifup are programs
_("<p>Use <b>NetworkManager</b> to have a desktop applet
manage connections for all interfaces. It is well-suited
to switching among wired and multiple wireless networks.</p>
") +
	    /* Network setup method help */
	    // NetworkManager and ifup are programs
_("<p>Use the <b>Traditional Method with <tt>ifup</tt></b>
if you do not run a desktop environment (GNOME or KDE)
or need to use multiple interfaces at once.</p>
"),
	    "init": ManagedInit,
	    "store": ManagedStore,
	    ],
	];

    term contents = `VBox (
	`HSquash ("MANAGED")
	);

    map functions = $[
	`abort : ReallyAbort,
    ];

    symbol ret = (symbol) CWM::ShowAndRun (
	$[
	    "widget_descr": wd,
	    "contents": contents,
	    /* Address dialog caption */
	    "caption": _("Network Setup Method"),
	    "back_button" : Label::BackButton (),
	    "next_button" : Label::NextButton (),
	    // #54027
	    "disable_buttons" : (Mode::normal ()? ["back_button"] : []),
	    "fallback_functions" : functions,
	    ]);
    // #148485: always show the device overview
    if (false && ret == `next && NetworkService::IsManaged ())
    {
	ret = `managed;
    }
    return ret;
}

define symbol IPv6Dialog () {
    map<string, map<string,any> > wd = $[
	"IPV6": $[
	    "widget": `radio_buttons,
	    // radio button group label, method of setup
	    "label": _("IPv6 Support"),
	    "items": [
		// radio button label
		// the user can enable IPv6
		["enable", _("&Enable IPv6")],
		// radio button label
		// the user can disable IPv6
		["disable", _("&Disable IPv6")],
		],
	    "opt": [],
	    "help":
	    /* IPv6 help */
_("<p>Select <b>Enable</b> IPv6 to enable ipv6 module in kernel.
It is possible to use IPv6 together with IPv4. This is default option.
") +
	    /* Network setup method help */
_("<p>Select <b>Disable</b> IPv6 to disable autoload kernel module for ipv6.
When ipv6 protocol is not used on your network, response time will be faster.
") +
_("<p>All changes will be applied after reboot.</p>"),
	    "init": IPv6Init,
	    "store": IPv6Store,
	    ],
	];

    term contents = `VBox (
	`HSquash ("IPV6")
	);

    map functions = $[
	`abort : ReallyAbort,
    ];

    symbol ret = (symbol) CWM::ShowAndRun (
	$[
	    "widget_descr": wd,
	    "contents": contents,
	    /* Address dialog caption */
	    "caption": _("Network Setup Method"),
	    "back_button" : Label::BackButton (),
	    "next_button" : Label::NextButton (),
	    // #54027
//	    "disable_buttons" : (Mode::normal ()? ["back_button"] : []),
	    "fallback_functions" : functions,
	    ]);
    // #148485: always show the device overview
    if (false && ret == `next && NetworkService::IsManaged ())
    {
	ret = `managed;
    }
    return ret;
}
/**
 * Start configuring a new interface (`add or `managed).
 * Also install needed packages.
 * @return whether to proceed with editing and commiting the config
 */
define boolean AddInterface (integer hwid) {
    //this is the map of kernel modules vs. requested firmware 
    //non-empty keys are firmware packages shipped by SUSE
    map <string, string> request_firmware = $[
	"atmel_pci" : "atmel-firmware", 
	"atmel_cs" : "atmel-firmware", 
	"bcm43xx" : "",
	"ipw2100" : "ipw-firmware",
	"ipw2200" : "ipw-firmware",
	"prism54" : "",
	"spectrum_cs" : "",
	"zd1201" : "",
	"zd1211rw" : "",
	"acx" : "",
	"at76_usb" : "atmel-firmware",
	"ipw3945" : "ipw-firmware",
	"rt61pci" : "", 
	"rt73usb" : "",
    ];

    Lan::Add ();
    Lan::SelectHW (hwid);
    Lan::SetDefaultsForHW ();

    // warn if selecting a card without a driver, #29296
    // TODO also for DSL...
    if (NetworkModules::Alias == "")
    {
	if (!Popup::ContinueCancel (_("The device does not have a driver module.
The driver may be built in the kernel.")))
	{
	    return false;
	}
    }
    else if(haskey(request_firmware, NetworkModules::Alias)){
	string fw = request_firmware[NetworkModules::Alias]:"";
	if (fw != ""){
	    if ((!Package::Installed(fw) && !Package::Available(fw))){
		
		//check if package with the firmware is available
		//i.e. if there are any inst. sources defined
		//and if the package is available on any of them

	        Popup::Message(sformat(_("The device needs a firmware to function properly. It can be installed from
%1 Add-On CD.\nTo install the firmware, add Add-On CD to your YaST installation sources and return 
to this configuration dialog."), Product::name));
		return false;
	    }
	}
	else {
		return (Popup::ContinueCancel(_("The device needs a firmware to function properly. It can be usually downloaded 
from your driver vendor web page.\nIf you have already downloaded and installed the firmware, click \'Continue\' 
to configure the device. Otherwise click \'Cancel\' and return to this dialog
once you have installed the firmware.")));
	}
    }
    // this is one of 3 places to install packages :-(
    // - kernel modules (InstallKernel): before loaded
    // - smpppd & kinternet: before net start
    // - wlan firmware: here, just because it is copied from modems
    //   #45960
    if(Lan::Requires != [] && Lan::Requires != nil) {
	if(PackagesInstall(Lan::Requires) != `next)
	    return false;
    }
    return true;
}

/**
 * Overview dialog
 * @return dialog result
 */
define any OverviewDialog() ``{
    ScreenName("lan-overview");

    /* Network cards overview dialog caption */
    string caption = _("Network Card Configuration Overview");

    /* Network cards overview dialog help 1/4 */
    string help = _("<p><b><big>Network Card Overview</big></b><br>
Obtain an overview of installed network cards. Additionally,
edit their configuration.<br></p>
") +

    /* Network cards overview dialog help 2/4 */
_("<p><b><big>Adding a Network Card:</big></b><br>
Press <b>Add</b> to configure a new network card manually.</p>
") +

    /* Network cards overview dialog help 3/4 */
_("<p><b><big>Editing or Deleting:</big></b><br>
Choose a network card to change or remove.
Then press <b>Edit</b> or <b>Delete</b> as desired.</p>
");

    // unused
    list<list> more_buttons = [
	// Button label
	// NetworkManager is a program name
	[`global_managed, _("&Managed by NetworkManager")],
	// Button label
	// NetworkManager is a program name
// `managed was for single interfaces
//	[`managed, _("&Managed by NetworkManager")],	
	];

    // FIXME: for now, rework the data for the new WizardHW

    WizardHW::CreateHWDialog (caption, help
	, [_("Name"), _("IP Address")]
	, [] );
    Wizard::EnableBackButton (); // ManagedDialog
    if (Mode::normal ()) {	// #182853
	// outside the installation proposal and autoyast, this is the last one
	Wizard::SetNextButton (`next, Label::FinishButton ());
    }

    boolean xenbr = !Mode::config() && Lan::HaveXenBridge (); // #196479
    boolean repaint = true;
    map ret = nil;
    while(true) {
	if (repaint)
	{
	    list<map<string,any> > overview = (list<map<string,any> >)Lan::Overview();
	    overview = overview + Lan::Unconfigured ();
	    y2debug("overview=%1",overview);
	    WizardHW::SetContents (overview);
	    if (xenbr)
	    {
		// #178848
		foreach (symbol b, [`add, `edit, `delete], {
		    UI::ChangeWidget (`id (b), `Enabled, false);
		});
	    }

	    repaint = false;
	}

	ret = WizardHW::UserInput();

	/* abort? */
	if(ret["event"]:nil == `abort || ret["event"]:nil == `cancel) {
	    if(ReallyAbort()) break;
	    else continue;
	}
	/* add */
	else if(ret["event"]:nil == `add) {
	    Lan::Add();
	    break;
	}
	/* edit */
	else if(ret["event"]:nil == `edit || ret["event"]:nil == `table) {
	    string dev = ret["selected"]:"";
	    if(dev == nil) {
		y2error("Empty device during Edit");
		continue;
	    }

	    if (substring (dev, 0, 1) == "-") // unconfigured
	    {
		integer i = tointeger (substring (dev, 1));
		if (! AddInterface (i))
		{
		    continue;
		}
	    }
	    else		// configured
	    {
		Lan::Edit(dev);
		if (Lan::startmode == "managed")
		{
		    // Continue-Cancel popup
		    if (!Popup::ContinueCancel (_("The interface is currently set to be managed
by the NetworkManager applet.

If you edit the settings for this interface here,
the interface will no longer be managed by NetworkManager.
")))
		    {
			continue; // means cancel
		    }
		    //
		    // TODO move the defaults to GetDefaultsForHW
		    Lan::startmode = "ifplugd";
		}

	    }

	    ret = $["event": `edit];
	    break;
	}
	/* managed - global */
	else if(ret["event"]:nil == `global_managed) {
	    NetworkService::SetManaged (! NetworkService::IsManaged ());
	    Lan::SetModified ();
	    repaint = true;
	}
	/* managed - per ifcfg */
	else if(ret["event"]:nil == `managed) {
	    string dev = ret["selected"]:"";
	    if(dev == nil) {
		y2error("Empty device during Edit");
		continue;
	    }

	    if (substring (dev, 0, 1) == "-") // unconfigured
	    {
		integer i = tointeger (substring (dev, 1));
		if (! AddInterface (i))
		{
		    continue;
		}
	    }
	    else		// configured
	    {
		Lan::Edit(dev);
	    }
	    Lan::startmode = "managed";
	    Lan::nm_name = "";	// no hwcfg
	    Lan::Commit ();
	    repaint = true;
	    continue;
	}
	/* delete */
	else if(ret["event"]:nil == `delete) {
	    string dev = ret["selected"]:"";

	    if (substring (dev, 0, 1) == "-") // unconfigured
		continue;

	    /* Popup text */
	    string pop = sformat(_("All additional addresses belonging to the interface %1
will be deleted as well.

Really continue?
"), dev);
	    if(Lan::HasAliases(dev) && Popup::YesNoHeadline(Label::WarningMsg(), pop) != true)
		continue;

	    Lan::Delete(dev);
	    Lan::Commit();
	    repaint = true;
	    continue;
	}
	else if(ret["event"]:nil == `next || ret["event"]:nil == `back) {
	    break;
	}
	else {
	    y2error("unexpected retcode: %1", ret);
	    continue;
	}
    }

    return ret["event"]:nil;
}

/* EOF */
}
