/**
 * File:	include/network/lan/address.ycp
 * Package:	Network configuration
 * Summary:	Network card adresss configuration dialogs
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 */

{

textdomain "network";

import "Arch";
import "CWM";
import "CWMTab";
import "Detection";
import "IP";
import "Label";
import "Lan";
import "Netmask";
import "NetworkDevices";
import "Popup";
import "ProductFeatures";
import "Routing";
import "SuSEFirewall4Network";
import "Wizard";
import "NetworkService";

include "network/summary.ycp";
include "network/widgets.ycp";
include "network/lan/help.ycp";
include "network/lan/hardware.ycp";
include "network/lan/virtual.ycp";

/**
 * obsoleted by GetDefaultsForHW
 * @return `next
 */
symbol ChangeDefaults () {
    return `next;
}

map <string, any> settings = $[];

string fwzone_initial = "";

boolean force_static_ip = ProductFeatures::GetBooleanFeature ("network", "force_static_ip");

/**
 * `RadioButtonGroup uses CurrentButton instead of Value, grrr
 * @param key widget id
 * @return what property to ask for to get the widget value
 */
symbol ValueProp (string key) {
    if (UI::QueryWidget (`id (key), `WidgetClass) == "YRadioButtonGroup")
    {
	return `CurrentButton;
    }
    return `Value;
}

    /**
 * Debug messages configurable at runtime
 * @param class debug class
 * @param msg message to log
 */
void my2debug (string class, string msg) {
    if (SCR::Read (.target.size, "/tmp/my2debug/" + class) != -1)
    {
	y2internal (class + ": " + msg);
    }
}

/**
 * Default function to init the value of a widget.
 * Used for push buttons.
 * @param key id of the widget
 */
void InitAddrWidget (string key) {
    any value = settings[key]:nil;
    my2debug ("AW", sformat ("init k: %1, v: %2", key, value));
    UI::ChangeWidget (`id (key), ValueProp (key), value);
}


/**
 * Default function to store the value of a widget.
 * @param key	id of the widget
 * @param event	the event being handled
 */
void StoreAddrWidget (string key, map event) {
    any value = UI::QueryWidget (`id (key), ValueProp (key));
    my2debug ("AW", sformat ("store k: %1, v: %2, e: %3", key, value, event));
    settings[key] = value;
}

/**
 * Default function to init the value of slave devices box.
 * @param key	id of the widget
 */
void InitSlave(string key)
{
    UI::ChangeWidget(`id(key), `SelectedItems, settings["SLAVES"]:[]);
}

/**
 * Default function to store the value of slave devices box.
 * @param key	id of the widget
 * @param key id of the widget
 */
void StoreSlave(string key, map event)
{
    settings["SLAVES"] = (list<string>)UI::QueryWidget (`id(key), `SelectedItems);
}

/**
 * Initialize a RadioButtonGroup
 * Group called FOO has buttons FOO_bar FOO_qux and values bar qux
 * @param key id of the widget
 */
void initBootProto (string key) {
 switch(settings["BOOTPROTO"]:""){
  case "static": UI::ChangeWidget(`id(`bootproto), `CurrentButton, `static);
		UI::ChangeWidget(`id(`ipaddr), `Value, settings["IPADDR"]:"");
		UI::ChangeWidget(`id(`netmask), `Value, settings["NETMASK"]:"");
		break;
  case "dhcp" : UI::ChangeWidget(`id(`bootproto), `CurrentButton, `dynamic);
		break;
  case "dhcp+autoip" : UI::ChangeWidget(`id(`bootproto), `CurrentButton, `dynamic);
		UI::ChangeWidget(`id(`dyn), `Value, `dhcp_auto);
		break;
  case "autoip" : UI::ChangeWidget(`id(`bootproto), `CurrentButton, `dynamic);
		UI::ChangeWidget(`id(`dyn), `Value, `auto);
		break;
  case "none" : UI::ChangeWidget(`id(`bootproto), `CurrentButton, `none);
		break;


 }
}


symbol handleBootProto (string key, map event) {
// if (event["EventReason"]:"" == "ValueChanged"){
  boolean none    = false;
  boolean dynamic = false;
  boolean stat  = false;
  switch((symbol)UI::QueryWidget(`id(`bootproto), `CurrentButton)){
   case `none : none=true;
		break;
   case `static: stat=true;
		break;
   default : dynamic=true;
		break;
  }
  UI::ChangeWidget(`dyn, `Enabled, dynamic);
  UI::ChangeWidget(`ipaddr, `Enabled, stat);
  UI::ChangeWidget(`netmask, `Enabled, stat);

// }
 return nil;
}


/**
 * Store a RadioButtonGroup
 * Group called FOO has buttons FOO_bar FOO_qux and values bar qux
 * @param key	id of the widget
 * @param event	the event being handled
 */
void storeBootProto (string key, map event) {
  switch((symbol)UI::QueryWidget(`id(`bootproto), `CurrentButton)){
   case `none : settings["BOOTPROTO"]="none";
		settings = remove(settings, "IPADDR");
		settings = remove(settings, "NETMASK");
		break;
   case `static: settings["BOOTPROTO"]="static";
		settings["IPADDR"]=(string)UI::QueryWidget(`ipaddr, `Value);
		settings["NETMASK"]=(string)UI::QueryWidget(`netmask, `Value);
		break;
   default : switch ((symbol)UI::QueryWidget(`dyn, `Value)){
		case `dhcp: settings["BOOTPROTO"]="dhcp";
			break;
		case `dhcp_auto: settings["BOOTPROTO"]="dhcp+autoip";
			break;
		case `auto: settings["BOOTPROTO"]="autoip";
			break;
	         }
		settings = remove(settings, "IPADDR");
		settings = remove(settings, "NETMASK");
		break;
  }
}

/**
 * Event handler for ifcfg name
 * enable or disable depending on whether we are adding a new interface
 * @param key	the widget receiving the event
 * @param event	the event being handled
 * @return nil so that the dialog loops on
 */
symbol HandleIfcfg (string key, map event) {
    UI::ChangeWidget (`id (key), `Enabled, Lan::operation == `add);
    return nil;
}

/**
 * Remap the buttons to their Wizard Sequencer values
 * @param key	the widget receiving the event
 * @param event	the event being handled
 * @return nil so that the dialog loops on
 */
symbol HandleButton (string key, map event) {
    any ret = event["ID"]:nil;
    map<any, symbol> symbols = $[

//	"HARDWARE": `hardware,
	"ADDITIONAL_ADDRESSES": `virtual,
	"S390": `s390,
	];
    return symbols[ret]:nil;
}

/**
 * Validator for IP adresses
 * used for IPADDR and REMOTEIP
 * @param key	the widget being validated
 * @param event	the event being handled
 * @return whether valid
 */
boolean ValidateAddrIP (string key, map event) {
    if (UI::QueryWidget(`bootproto, `CurrentButton) == `static)
    {
	return ValidateIP (key, event);
    }
    return true;
}

/**
 * Validator for network masks adresses
 * @param key	the widget being validated
 * @param event	the event being handled
 * @return whether valid
 */
boolean ValidateNetmask (string key, map event) {
    // TODO general CWM improvement idea: validate and save only nondisabled
    // widgets
    if (UI::QueryWidget(`bootproto, `CurrentButton) == `static)
    {
	string ipa = (string) UI::QueryWidget (`id (key), `Value);
	return Netmask::Check (ipa);
    }
    return true;
}

/**
 * Validator for ifcfg names
 * @param key	the widget being validated
 * @param event	the event being handled
 * @return whether valid
 */
boolean ValidateIfcfgType (string key, map event) {
    if (Lan::operation == `add)
    {
	string ifcfgtype = (string) UI::QueryWidget (`id (key), `Value);

	// validate device type, misdetection
	if (ifcfgtype != Lan::type)
	{
	    UI::SetFocus(`id (key));
	    if (!Popup::ContinueCancel (
_("You have changed the interface type from the one
that has been detected. This only makes sense
if you know that the detection is wrong.")))
	    {
		return false;
	    }
	}

	string ifcfgid = (string) UI::QueryWidget (`id ("IFCFGID"), `Value);
	string ifcfgname = NetworkDevices::device_name (ifcfgtype, ifcfgid);

	// Check should be improved to find differently named but
	// equivalent configs (eg. by-mac and by-bus, depends on the
	// current hardware)
	if (NetworkDevices::Check(ifcfgname))
	{
	    UI::SetFocus(`id (key));
	    /* Popup text */
	    Popup::Error (sformat (_("Configuration %1 already present."),
				   ifcfgname));
	    return false;
	}
    }
    return true;
}

/**
 * Initialize the dialog as a whole
 * Sets default focus
 * @param key id of the widget
 */
/*
void InitDialog (string key) {
    UI::SetFocus (`id ("IPADDR"));
}
*/

/**
 * If the traffic would be blocked, ask the user
 * if he wants to change it
 * @param event	the event being handled
 * @return change it?
 */
boolean NeedToAssignFwZone (map event) {
    any ret = event["ID"]:nil;
    if (ret == `next)
    {
	// If firewall is active and interface in no zone, nothing
	// gets through (#62309) so warn and redirect to details
	string type = (string) UI::QueryWidget (`id ("IFCFGTYPE"), `Value);
	string id = (string) UI::QueryWidget (`id ("IFCFGID"), `Value);
	string name = NetworkDevices::device_name (type, id);
	if (SuSEFirewall4Network::IsOn () &&
	    SuSEFirewall4Network::GetZoneOfInterface (name) == "" &&
	    SuSEFirewall4Network::UnconfiguredIsBlocked ())
	{
	    return Popup::YesNoHeadline (Label::WarningMsg (),
_("The firewall is active, but this interface is not
in any zone. All its traffic would be blocked.
Assign it to a zone now?"));
	}
    }
    return false;
}

/**
 * Validator for network masks adresses
 * @param key	the widget being validated
 * @param event	the event being handled
 * @return whether valid
 */
boolean ValidateDialog (string key, map event) {
    if (UI::QueryWidget(`bootproto, `CurrentButton) == `static)
    {
	string k = "IPADDR";
	string ipa = (string) UI::QueryWidget (`id (k), `Value);
	// validate duplication
	if (Detection::DuplicateIP (ipa))
	{
	    /* Popup text */
	    string pop = _("Duplicate IP address detected.
Really continue?
");
	    UI::SetFocus(`id (k));
	    if (! Popup::YesNoHeadline(Label::WarningMsg(), pop))
	    {
		return false;
	    }
	}
    }
    if (NeedToAssignFwZone (event))
    {
	UI::FakeUserInput ($["ID": "t_general"]);
	return false;
    }
    return true;
}

/**
 * Store values computed from the whole dialog
 * @param key	the widget being validated
 * @param event	the event being handled
 */
/*
void StoreDialog (string key, map event) {
    return;
}
*/


/**
 * Initialize value of firewall zone widget
 * (disables it when SuSEFirewall is not installed)
 * @param key id of the widget
 */
void InitFwZone(string key) {
    if( SuSEFirewall4Network::IsInstalled() )
	UI::ChangeWidget(`id("FWZONE"), `Value, settings["FWZONE"]:"");
    else
	UI::ChangeWidget(`id("FWZONE"), `Enabled, false);
}


map<string, map<string,any> > widget_descr_local = $[
    "HWDIALOG" : $[
	"widget" : `custom,
	"custom_widget" :
		`ReplacePoint(`id(`hw_content), `Empty()),
	"init" : initHwDialog,
	"handle" : handleHW,
	"store" : storeHW,
	"help" : hw_help
		],
    "AD_ADDRESSES" : $[
	"widget" : `custom,
	"custom_widget" : 
		    /* Frame label */
		    `Frame(`id(`f_additional), _("Additional Addresses"), `HBox(`HSpacing(3), `VBox(
			`VSpacing(1),
			`Table(`id(`table), `opt(`notify), `header(
	                    /* Table header label */
	                    _("Alias Name"),
	                    /* Table header label */
	                    _("IP Address"),
	                    /* Table header label */
	                    _("Netmask")), []),
			`HBox(
			    /* PushButton label */
			    `PushButton(`id(`add), _("Ad&d")),
			    /* PushButton label */
			    `PushButton(`id(`edit), `opt(`disabled), _("&Edit")),
			    /* PushButton label */
			    `PushButton(`id(`delete), `opt(`disabled), _("De&lete"))),
			`VSpacing(1)
			),
			`HSpacing(3))),
	"help" : help["additional"]:"",
	"init" : initAdditional,
	"handle" : handleAdditional,
	"store" : storeAdditional
	
	],
    "_DIALOG": $[
	"widget": `empty,
	"help": 
    /* Address dialog help 8/8 */
    _("<p>Clicking <b>Next</b> completes the configuration.</p>"),
	"validate_type": `function,
	"validate_function": ValidateDialog,
//	"init": InitDialog,
//	"store": StoreDialog,
	],

    "IFNAME": $[
	"widget": `textentry,
	"label": _("&Name of Interface"),
	"opt": [`hstretch],
	"help": _("<p>TODO kind of vague!</p>"),
	],
    "BINDTOHW": $[
	"widget": `combobox,
	"label": _("Binding &Characteristic"),
	"opt": [`hstretch],
	// IDEA: "help" is the traditional detached help, has to include
	// widget name; "tooltip" or "toolhelp" is visually bound to the
	// widget, does not need to contain its name (the translator comment
	// needs to, though)
	"help": _("<p>FIXME better help! Which hardware to bind to</p>"),
	// FIXME FAKE: get real values dynamically
	"items": [
	    // synchronize keys with ... whatever
	    // combo box item. %1 is like "00:de:ad:po:rk:00"
	    ["mac", sformat (_("MAC Address: %1"), "00:de:ad:po:rk:00")],
	    // combo box item. %1 is like "pci-0000:01:09.0"
	    ["bus", sformat (_("Bus Path: %1"), "pci-0000:01:09.0")],
	    // combo box item. %1 is like "1022-2000"
	    ["vpid", sformat (_("Product ID: %1"), "1022-2000")],
	    // combo box item. %1 is like "1022-2000-1259-2700"
	    ["vpsid", sformat (_("Product Sub-ID: %1"), "1022-2000-1259-2700")],
	    ],
	],

    "FWZONE": $[
	"widget": `combobox,
	// Combo Box label
	"label": "Assign Interface to Firewall &Zone",
	"opt": [`hstretch],
	"help": help["fwzone"]:"",
	"init" : InitFwZone,
	],
    "MANDATORY": $[
	"widget": `checkbox,
	// check box label
	"label": _("&Mandatory Interface"),
	"opt": [],
	"help": help["mandatory"]:"",
	],
    "MTU": $[
	"widget": `textentry,
	// textentry label, Maximum Transfer Unit
	"label": _("Set &MTU"),
	"opt": [`hstretch],
	"help": help["mtu"]:"",
	],
    "IFCFGTYPE": $[
	"widget": `combobox,
	/* ComboBox label */
	"label": _("&Device Type"),
	"opt": [`hstretch, `notify],
	"help": "",
	// "items" will be filled in the dialog itself
	"handle": HandleIfcfg,
	"validate_type": `function,
	"validate_function": ValidateIfcfgType,
	],

    "IFCFGID": $[
	"widget": `combobox,
	/* ComboBox label */
	"label": _("&Configuration Name"),
	"opt": [`hstretch, `editable],
	"help": "",
	"valid_chars": NetworkDevices::ValidCharsIfcfg (),
	"handle": HandleIfcfg,
	],

    "BONDSLAVE": $[
        "widget": `multi_selection_box,
        "label": _("Bond &Slaves"),
        "opt": [`shrinkable],
        "items" : [ ],
        "init": InitSlave,
        "store": StoreSlave,
        "help": help["bondslave"]:"",
    ],

    "BONDOPTION": $[
        "widget": `combobox,
        /* ComboBox label */
        "label": _("Bond &Driver Options"),
        "opt": [`hstretch, `editable],
        "help": _("<p>Select the bond driver options, and edit it if you need. </p>"),
        "items": [["mode=balance-rr"], ["mode=active-backup"], ["mode=balance-xor"],
                  ["mode=broadcast"], ["mode=802.3ad"], ["mode=balance-tlb"], ["mode=balance-alb"]],
    ],

    "BOOTPROTO": $[
	"widget": `custom,
	"custom_widget":
	  `RadioButtonGroup(`id(`bootproto),
		`VBox(
		`Left(`RadioButton(`id(`none),`opt(`notify),  _("No IP Address (for Bonding Devices)"))),
		`Left(`HBox(
		 `RadioButton(`id(`dynamic), `opt(`notify), _("Dynamic Address")),
		  `ComboBox(`id(`dyn), "", [
			`item(`id(`dhcp), "DHCP"),
			`item(`id(`dhcp_auto), "DHCP+Zeroconf"),
			`item(`id(`auto), "Zeroconf")
		   ])
		 )),
		`VBox(
		 `Left(`RadioButton(`id(`static), `opt(`notify), _("Statically assigned IP Address"))),
		  `HBox(
		  `TextEntry(`id(`ipaddr), _("&IP Address")), `TextEntry(`id(`netmask),  _("&Subnet Mask"))
		   )
		 )
		)
	    ),
	"help": force_static_ip ? help["force_static_ip"]:"" : help["bootproto"]:"" + help["netmask"]:"",
	"init": initBootProto,
	"handle": handleBootProto,
	"store": storeBootProto,
	],

/*
    "IPADDR": $[
	"widget": `textentry,
	"label": _("&IP Address"),
	"help": "",		// merged to either REMOTEIP or NETMASK
	"handle": HandleStaticAddress,
	"validate_type": `function_no_popup,
	"validate_function": ValidateAddrIP,
	"validate_help": _("The IP address is invalid.")+ "\n" + IP::Valid4 (),
	],
    "NETMASK": $[
	"widget": `textentry,
	"label": _("&Subnet Mask"),
	"help": help["netmask"]:"",
	"handle": HandleStaticAddress,
	"validate_type": `function_no_popup,
	"validate_function": ValidateNetmask,
	"validate_help": _("The subnet mask is invalid."), // TODO describe a valid one
	],

*/

    "REMOTEIP": $[
	"widget": `textentry,
	/* Text entry label */
	"label": _("R&emote IP Address"),
	"help": help["remoteip"]:"",
	"validate_type": `function_no_popup,
	"validate_function": ValidateAddrIP,
	// validation error popup
	"validate_help": _("The remote IP address is invalid.") + "\n" + IP::Valid4 (),
	],

/*
    "GATEWAY": $[
	"widget": `textentry,
	"label": _("Default &Gateway"),
	"opt": [],
	"help": _("<p><b>Default Gateway</b> TODO: the original help is bad</p>"),
	"handle": HandleStaticAddress,
	],
*/
    "ADVANCED_MB": $[
	"widget": `menu_button,
	// menu button label
	"label": _("&Advanced..."),
	"opt": [`hstretch],
	"help": "",
	// "items" will be filled in the dialog itself
	"init": CWM::InitNull,
	"store": CWM::StoreNull,
	"handle": HandleButton,
	],
/*
    "ADDITIONAL_ADDRESSES": $[
	"widget": `push_button,
	// push button label
	"label": _("Addi&tional Addresses"),
	"opt": [],
	"help": "",
	"init": CWM::InitNull,
	"store": CWM::StoreNull,
	"handle": HandleButton,
	],
*/
    // leftovers
    "S390": $[
	"widget": `push_button,
	// push button label
	"label": _("&S/390"),
	"opt": [],
	"help": "",
	"init": CWM::InitNull,
	"store": CWM::StoreNull,
	"handle": HandleButton,
	],
    ];

/**
 * @param types netowrk card types
 * @return their descriptions for CWM
 */
list< list<string> > BuildTypesListCWM (list<string> types) {
    return maplist(string t, types, {
	return [t, DeviceType(t)];
    });
}


/**
 * Dialog for setting up IP address
 * @return dialog result
 */
define any AddressDialog() {
    ScreenName("lan-address");

    string ifname = NetworkDevices::device_name (Lan::type, Lan::device);
    string fwzone = SuSEFirewall4Network::GetZoneOfInterface (ifname);

    // If firewall is active and interface in no zone, nothing
    // gets through (#62309) so add it to the external zone
    if (fwzone == "" &&
	Lan::operation == `add &&
	SuSEFirewall4Network::IsOn () &&
	SuSEFirewall4Network::UnconfiguredIsBlocked ())
    {
	fwzone = "EXT";
	y2milestone ("Defaulting to EXT");
    }

    fwzone_initial = fwzone;

    settings = $[
	// general tab:
//	"IFNAME": ifname,
//	"BINDTOHW": "mac",	// FIXME
	"STARTMODE": Lan::startmode,
	"USERCONTROL": Lan::usercontrol,
	// problems when renaming the interface?
	"FWZONE": fwzone,
	"MTU": Lan::mtu,

	// address tab:
	"BOOTPROTO": Lan::bootproto,
	"IPADDR": Lan::ipaddr,
	"NETMASK": Lan::netmask,
	"REMOTEIP": Lan::remoteip,

	"IFCFGTYPE": Lan::type,
	"IFCFGID": Lan::device,
	];




    string drvtype = Lan::DriverType (settings["IFCFGTYPE"]:"");

    boolean is_ptp = drvtype == "ctc" || drvtype == "iucv";
    // TODO: dynamic for dummy. or add dummy from outside?
    boolean no_dhcp = is_ptp || settings["IFCFGTYPE"]:"" == "dummy" || Lan::alias != "";

    if(settings["BOOTPROTO"]:"" == "static" && settings["IPADDR"]:"" == "" && !no_dhcp) settings["BOOTPROTO"] = "dhcp"; 

    // #65524
    if (Lan::operation == `add && force_static_ip)
    {
	settings["BOOTPROTO"] = "static";
    }

    // FIXME duplicated in hardware.ycp
    list<string> device_types = [ "arc", "bnep", "dummy", "eth", "fddi", "myri", "tr", "usb", "wlan", "bond" ];

    if(Arch::s390 ())
	device_types = [ "eth", "tr", "hsi", "ctc", "escon", "iucv", "qeth", "lcs" ];

    if(Arch::ia64 ())
	device_types = add(device_types, "xp");

    boolean fw_is_installed = SuSEFirewall4Network::IsInstalled();

    map<string, map<string,any> > wd = (map<string, map<string,any> >) union (widget_descr, widget_descr_local);


    wd["STARTMODE"] = MakeStartmode (
	["auto", "ifplugd", "hotplug", "manual", "off", "nfsroot" ]);

    wd["IFCFGTYPE", "items"] = BuildTypesListCWM (device_types);
    wd["IFCFGID", "items"] = [[settings["IFCFGID"]:"",
			       settings["IFCFGID"]:""]];
    //wd["BINDTOHW", "items"] = ...;

    if ( fw_is_installed )
        wd["FWZONE", "items"] = SuSEFirewall4Network::FirewallZonesComboBoxItems();
    else
	wd["FWZONE", "items"] = [ ["", _("Firewall is not installed") ] ];
    

    term label = `HBox (
	    `HSpacing(0.5),
	    // The combo is a hack to allow changing misdetected
	    // interface types. It will work in some cases, like
	    // overriding eth to wlan but not in others where we would
	    // need to change the contents of the dialog. #30890.
	    "IFCFGTYPE",
	    `HSpacing(1.5),
	    "IFCFGID",
	    `HSpacing(0.5)
	);
    if(Lan::operation != `add) {
	if(Lan::alias == "") {
	    settings["IFCFG"] = NetworkDevices::device_name(NetworkDevices::RealType(Lan::type, Lan::hotplug), Lan::device);
	}
	else {
	    settings["IFCFG"] = NetworkDevices::alias_name(NetworkDevices::RealType(Lan::type, Lan::hotplug), Lan::device, Lan::alias);
	}
    }
    
    list<string> mb_items = [];
//    if (!NetworkService::IsManaged()) mb_items = add(mb_items, "ADDITIONAL_ADDRESSES");

    // Allow changing s390 options, except for iucv, where the option
    // is in the name of the hwcfg file. Haven't figured it out yet.
    if (Arch::s390 () && drvtype != "iucv")
    {
	mb_items = add(mb_items, "S390");
    }
    wd["ADVANCED_MB", "items"] = maplist (string btn, mb_items, {
	// TODO helps
	return [btn, wd[btn, "label"]:btn];
    });

    term frame2= `Empty();
    if (size(mb_items)>0) frame2 = `MarginBox (
	1, 0,
	`Frame(_("Detailed Settings"), `HBox(`HStretch(),
	`HSquash(`VBox(
	    `VSpacing(0.4),
//	    "HOSTNAME_B",
//	    "ROUTING",
	    "ADVANCED_MB",
	    `VSpacing(0.4)
	)),
	`HStretch()
    )));

    if(Lan::alias != "")
	frame2 = `VSpacing(0);

    term address_p2p_contents =
	`Frame (
	    "",		// labelless frame
	    `VBox (
		"IPADDR",
		"REMOTEIP")
	    );

    term address_static_contents =
	`Frame (
	    "",		// labelless frame
	    `VBox (
		"IPADDR",
		"NETMASK",
		// TODO new widget, add logic
		//"GATEWAY"
		`Empty ()
		)
	    );

    term address_dhcp_contents = `VBox( "BOOTPROTO" );
/*
`VBox (
	`RadioButtonGroup (
	    `id ("BOOTPROTO"),	// CWM must not expand `id
	    `MarginBox (1, 0,
		`VBox (
//		    `Left ("BOOTPROTO_none"),
		    `Left ("BOOTPROTO_dhcp"), // TODO: widget attribute align: left
		    `Left ("BOOTPROTO_dhcp+autoip"),
		    `Left ("BOOTPROTO_autoip"),
		    `Left ("BOOTPROTO_static"),
		    address_static_contents)
		)
	    ),
	"BOOTPROTO" // empty, handler; must come after the individual buttons to override their dumb default handlers
	);
*/
    term just_address_contents =
	is_ptp? address_p2p_contents:
	(no_dhcp? address_static_contents: address_dhcp_contents);

    term bond = `MarginBox(1, 0, `Frame( "", `VBox("BONDSLAVE", "BONDOPTION")));

    if (Lan::type == "bond")
    {
        settings["SLAVES"] = Lan::bond_slaves;

        //get all eth devices
        map<string, map<string, map<string, any> > > devices = (map<string, map<string, map<string, any> > >)NetworkDevices::FilterDevices("");
	map<string, map<string, any> > avails= devices["eth"]:$[];

        //filter the eth devices (BOOT_PROTO=none && START_MODE=off)
        foreach (string num, map<string, any> value, avails, 
        {
            if (((string)value["BOOTPROTO"]:"" == "none") && ((string)value["STARTMODE"]:"" == "off"))
            wd["BONDSLAVE", "items"] = add (wd["BONDSLAVE", "items"]:[], [NetworkDevices::device_name("eth", num)] );
        });

        settings["BONDOPTION"] = Lan::bond_option;

        //fill up the drop list and make the default value first
        wd["BONDOPTION", "items"] = filter(list<string> v, wd["BONDOPTION", "items"]:[],
        {
            return v[0]:"" != Lan::bond_option;
        });
        wd["BONDOPTION", "items"] = prepend(wd["BONDOPTION", "items"]:[], [Lan::bond_option]);
    }


    term address_contents = `VBox(
	`Left(label),
	just_address_contents,
	frame2,
	"_DIALOG"
     );
    if (Lan::type == "bond")
    {
        address_contents = `VBox(
                `Left(label),
		just_address_contents,
		bond,
		frame2,
		"_DIALOG"
	);
    }
    else
    {
	address_contents = `VBox(
		`Left(label),
		just_address_contents,
		"AD_ADDRESSES",
		frame2,
		"_DIALOG"
	);
    }


    map functions = $[
        "init" : InitAddrWidget,
        "store" : StoreAddrWidget,
	`abort : ReallyAbort,
    ];



   map<string, any> wd_content = $[
                "tab_order" : ["t_general", "t_addr", "hardware"],
                "tabs" : $[
                    "t_general" : $[
                        "header" : _("&General"),
                        "contents" : 
    `MarginBox (1, 0,
	`VBox (
	    `MarginBox (1, 0,
	        `VBox(
		    // TODO:
		    // "MANDATORY",
		    `Frame( _("Device Activation"), `HBox(("STARTMODE"), `HStretch())),
		    `VSpacing(0.4),
		    `Frame(_("Firewall Zone"), `HBox(("FWZONE"), `HStretch())),
		    `VSpacing(0.4),
		    `Frame(_("Device Control"), `HBox(("USERCONTROL"), `HStretch())) ,
		    `VSpacing (0.4),
	            `Frame(_("Maximum Transfer Unit (MTU)"), `HBox(("MTU"), `HStretch())),
		    `VStretch()
		    )
		)
	      )
	    ),
                        // FIXME we have helps per widget and for the whole
                        // tab set but not for one tab
                        "help": _("<p>Configure the detailed network card settings here.</p>"),
                    ],
                    "t_addr" : $[
                        // FIXME: here it does not complain about missing
                        // shortcuts
                        "header" : _("&Address"),
                        "contents" : address_contents,
                        // Address tab help
                        "help": _("<p>Configure your IP address.</p>"),
                    ],
                    "hardware" : $[
                        "header" : _("&Hardware"),
                        "contents" : `VBox( "HWDIALOG" )
//                      "help" : hw_help,
//                        "widget_names" : [],
                    ],
                    "t3" : $[
                        "header" : _("&Wireless"),
                        "contents" : `Empty (),
                        "widget_names" : [],
                    ]
                ],
                "initial_tab" : "t_addr",
                "widget_descr" : wd,
                "tab_help" : "",
                "fallback_functions" : functions,
            ];

 if (Lan::operation == `add) wd_content["initial_tab"] = "hardware";

    wd = (map<string, map<string,any> >) union (wd, $[
	"tab" : CWMTab::CreateWidget (wd_content)
        ]);

    term contents2 = `HBox ("tab");


    any ret = CWM::ShowAndRun (
	$[
	    "widget_names": ["tab"],
	    "widget_descr": wd,
	    "contents": contents2,
	    /* Address dialog caption */
	    "caption": _("Network Card Setup"),
	    "back_button" : Label::BackButton (),
	    "next_button" : Label::NextButton (),
	    "fallback_functions" : functions,
	    ]);
    y2milestone ("ShowAndRun: %1", ret);
 
    if (ret != `back && ret != `abort)
    {
	string ifcfgname = NetworkDevices::device_name (
	    settings["IFCFGTYPE"]:"",
	    settings["IFCFGID"]:"");

	// general tab
	Lan::startmode = settings["STARTMODE"]:"";
	Lan::usercontrol = settings["USERCONTROL"]:false;

	if (fw_is_installed) {
	    string zone = settings["FWZONE"]:"";
	    if (zone != fwzone_initial)
	        SuSEFirewall4Network::ChangedByUser(true);
	    SuSEFirewall4Network::ProtectByFirewall (ifcfgname, zone, zone != "");
	}

	Lan::mtu = settings["MTU"]:"";

	// address tab
	if(Lan::operation == `add) {
	    Lan::device = NetworkDevices::device_num(ifcfgname);
	    Lan::type = NetworkDevices::device_type(ifcfgname);
	}

	Lan::bootproto = settings["BOOTPROTO"]:"";
	if (Lan::bootproto == "static") // #104494
	{
	    Lan::ipaddr = settings["IPADDR"]:"";
	    Lan::netmask = settings["NETMASK"]:"";
	    Lan::remoteip = settings["REMOTEIP"]:"";
	}
	else
	{
	    Lan::ipaddr = "";
	    Lan::netmask = "";
	    Lan::remoteip = "";
	    // fixed bug #73739 - if dhcp is used, dont set default gw statically
	    Routing::RemoveDefaultGw();
	}
    }

    if (Lan::type == "bond")
    {
        Lan::bond_option = settings["BONDOPTION"]:"";
	Lan::bond_slaves = (list<string>)settings["SLAVES"]:[];
    }

    // proceed with WLAN settings if appropriate, #42420
    if (ret == `next && Lan::type == "wlan" && Lan::alias == "")
    {
	ret = `wire;
    }

    if(ret == `routing)
	Routing::SetDevices(NetworkDevices::List(""));


    return ret;
}

/* EOF */
}
